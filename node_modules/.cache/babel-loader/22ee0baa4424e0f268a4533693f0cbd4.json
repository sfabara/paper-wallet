{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar Hash = require('../../crypto/hash');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar Sighash = require('../sighash');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar TransactionSignature = require('../signature');\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\n\n\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\n\ninherits(PublicKeyHashInput, Input);\n/* jshint maxparams: 5 */\n\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @return {Array} of objects that can be\n */\n\nPublicKeyHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n\n  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n      sigtype: sigtype\n    })];\n  }\n\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyHashInput.prototype.addSignature = function (transaction, signature) {\n  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyHashIn(signature.publicKey, signature.signature.toDER(), signature.sigtype));\n  return this;\n};\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\n\n\nPublicKeyHashInput.prototype.clearSignatures = function () {\n  this.setScript(Script.empty());\n  return this;\n};\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\n\n\nPublicKeyHashInput.prototype.isFullySigned = function () {\n  return this.script.isPublicKeyHashIn();\n};\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.prototype._estimateSize = function () {\n  return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyHashInput;","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/lib/transaction/input/publickeyhash.js"],"names":["inherits","require","$","BufferUtil","Hash","Input","Output","Sighash","Script","Signature","TransactionSignature","PublicKeyHashInput","apply","arguments","prototype","getSignatures","transaction","privateKey","index","sigtype","hashData","checkState","output","sha256ripemd160","publicKey","toBuffer","SIGHASH_ALL","equals","script","getPublicKeyHash","prevTxId","outputIndex","inputIndex","signature","sign","addSignature","isValidSignature","setScript","buildPublicKeyHashIn","toDER","clearSignatures","empty","isFullySigned","isPublicKeyHashIn","SCRIPT_MAX_SIZE","_estimateSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Hash = require('../../crypto/hash');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\n/* jshint maxparams: 5 */\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @return {Array} of objects that can be\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n\n  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature) {\n  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyHashIn(\n    signature.publicKey,\n    signature.signature.toDER(),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn();\n};\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyHashInput;\n"]},"metadata":{},"sourceType":"script"}