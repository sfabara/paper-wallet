{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar BufferUtil = require('../util/buffer');\n\nvar ec = require('elliptic').curves.secp256k1;\n\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\n\nvar Point = function Point(x, y, isRed) {\n  var point = ecPoint(x, y, isRed);\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\n\nPoint.fromX = function fromX(odd, x) {\n  var point = ecPointFromX(odd, x);\n  point.validate();\n  return point;\n};\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\n\n\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\n\n\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\n\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\n\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\n\n\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  if (this.getX().cmp(BN.Zero) === 0 || this.getY().cmp(BN.Zero) === 0) {\n    throw new Error('Invalid x,y value for curve, cannot equal 0.');\n  }\n\n  var p2 = ecPointFromX(this.getY().isOdd(), this.getX());\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n  var xValidRange = this.getX().gt(BN.Minus1) && this.getX().lt(Point.getN());\n  var yValidRange = this.getY().gt(BN.Minus1) && this.getY().lt(Point.getN());\n\n  if (!xValidRange || !yValidRange) {\n    throw new Error('Point does not lie on the curve');\n  } //todo: needs test case\n\n\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n\n  if (odd) {\n    prefix = new Buffer([0x03]);\n  } else {\n    prefix = new Buffer([0x02]);\n  }\n\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\nmodule.exports = Point;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/crypto/point.js"],"names":["BN","require","BufferUtil","ec","curves","secp256k1","ecPoint","curve","point","bind","ecPointFromX","pointFromX","Point","x","y","isRed","validate","prototype","Object","getPrototypeOf","fromX","odd","getG","g","getN","n","toArray","_getX","getX","_getY","getY","isInfinity","Error","cmp","Zero","p2","isOdd","xValidRange","gt","Minus1","lt","yValidRange","mul","pointToCompressed","xbuf","toBuffer","size","ybuf","prefix","length","Buffer","concat","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\nvar ec = require('elliptic').curves.secp256k1;\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  var point = ecPoint(x, y, isRed);\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  var point = ecPointFromX(odd, x);\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  if (this.getX().cmp(BN.Zero) === 0 || this.getY().cmp(BN.Zero) === 0){\n    throw new Error('Invalid x,y value for curve, cannot equal 0.');\n  }\n\n  var p2 = ecPointFromX(this.getY().isOdd(), this.getX());\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n  var xValidRange = (this.getX().gt(BN.Minus1) && this.getX().lt(Point.getN()));\n  var yValidRange = (this.getY().gt(BN.Minus1) && this.getY().lt(Point.getN()));\n\n  if ( !xValidRange || !yValidRange ) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = new Buffer([0x03]);\n  } else {\n    prefix = new Buffer([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\nmodule.exports = Point;\n"]},"metadata":{},"sourceType":"script"}