{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar BlockHeader = require('./blockheader');\n\nvar BufferUtil = require('../util/buffer');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar Hash = require('../crypto/hash');\n\nvar JSUtil = require('../util/js');\n\nvar Transaction = require('../transaction');\n\nvar $ = require('../util/preconditions');\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\n\n\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n\n    if (arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n\n  _.extend(this, info);\n\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n  return this;\n}\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\n\n\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\n\n\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n/**\n * @returns {Buffer} - A buffer of the block\n */\n\n\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\n\n\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(new Buffer(this.hashes[i], 'hex'));\n  }\n\n  bw.writeVarintNum(this.flags.length);\n\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n\n  return bw;\n};\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\n\n\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\n\n\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions\n\n  if (this.hashes.length > this.numTransactions) {\n    return false;\n  } // Can't have more flag bits than num hashes\n\n\n  if (this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n\n  var opts = {\n    hashesUsed: 0,\n    flagBitsUsed: 0\n  };\n\n  var root = this._traverseMerkleTree(height, 0, opts);\n\n  if (opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @private\n */\n\n\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts) {\n  /* jshint maxcomplexity:  12*/\n\n  /* jshint maxstatements: 20 */\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n\n  if (opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n\n  var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;\n\n  if (depth === 0 || !isParentOfMatch) {\n    if (opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n\n    var hash = this.hashes[opts.hashesUsed++];\n\n    if (depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n\n    return new Buffer(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);\n\n    var right = left;\n\n    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {\n      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);\n    }\n\n    return Hash.sha256sha256(new Buffer.concat([left, right]));\n  }\n};\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\n\n\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return this.numTransactions + (1 << height) - 1 >> height;\n};\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\n\n\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n\n  return height;\n};\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\n\n\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n  var hash = tx;\n\n  if (tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(new Buffer(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n\n  var height = this._calcTreeHeight();\n\n  this._traverseMerkleTree(height, 0, {\n    txs: txs\n  });\n\n  return txs.indexOf(hash) !== -1;\n};\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\n\n\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n\n  return info;\n};\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\n\n\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/block/merkleblock.js"],"names":["_","require","BlockHeader","BufferUtil","BufferReader","BufferWriter","Hash","JSUtil","Transaction","$","MerkleBlock","arg","info","isBuffer","_fromBufferReader","isObject","header","fromObject","numTransactions","hashes","flags","TypeError","extend","_flagBitsUsed","_hashesUsed","fromBuffer","buf","fromBufferReader","br","prototype","toBuffer","toBufferWriter","concat","bw","write","writeUInt32LE","writeVarintNum","length","i","Buffer","writeUInt8","toObject","toJSON","validMerkleTree","checkState","isArray","height","_calcTreeHeight","opts","hashesUsed","flagBitsUsed","root","_traverseMerkleTree","equals","merkleRoot","traverseMerkleTree","depth","pos","txs","isParentOfMatch","hash","push","left","right","_calcTreeWidth","sha256sha256","calcTreeWidth","calcTreeHeight","hasTransaction","tx","checkArgument","isUndefined","reverse","id","toString","indexOf","finished","readUInt32LE","numHashes","readVarintNum","read","numFlags","readUInt8","obj","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar JSUtil = require('../util/js');\nvar Transaction = require('../transaction');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n    if(arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n  _.extend(this,info);\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n  return this;\n}\n\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(new Buffer(this.hashes[i], 'hex'));\n  }\n  bw.writeVarintNum(this.flags.length);\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n  return bw;\n};\n\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array');\n\n  // Can't have more hashes than numTransactions\n  if(this.hashes.length > this.numTransactions) {\n    return false;\n  }\n\n  // Can't have more flag bits than num hashes\n  if(this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n  var opts = { hashesUsed: 0, flagBitsUsed: 0 };\n  var root = this._traverseMerkleTree(height, 0, opts);\n  if(opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @private\n */\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts) {\n  /* jshint maxcomplexity:  12*/\n  /* jshint maxstatements: 20 */\n\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n\n  if(opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n  var isParentOfMatch = (this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7)) & 1;\n  if(depth === 0 || !isParentOfMatch) {\n    if(opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n    var hash = this.hashes[opts.hashesUsed++];\n    if(depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n    return new Buffer(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth-1, pos*2, opts);\n    var right = left;\n    if(pos*2+1 < this._calcTreeWidth(depth-1)) {\n      right = this._traverseMerkleTree(depth-1, pos*2+1, opts);\n    }\n    return Hash.sha256sha256(new Buffer.concat([left, right]));\n  }\n};\n\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return (this.numTransactions + (1 << height) - 1) >> height;\n};\n\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n  return height;\n};\n\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string',\n      'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n\n  var hash = tx;\n  if(tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(new Buffer(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n  var height = this._calcTreeHeight();\n  this._traverseMerkleTree(height, 0, { txs: txs });\n  return txs.indexOf(hash) !== -1;\n};\n\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;\n"]},"metadata":{},"sourceType":"script"}