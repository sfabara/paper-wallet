{"ast":null,"code":"'use strict';\n\nvar BN = require('bn.js');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n\nvar reversebuf = function reversebuf(buf) {\n  var buf2 = new Buffer(buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function (n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function (str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\n\n\nBN.fromSM = function (buf, opts) {\n  var ret;\n\n  if (buf.length === 0) {\n    return BN.fromBuffer(new Buffer([0]));\n  }\n\n  var endian = 'big';\n\n  if (opts) {\n    endian = opts.endian;\n  }\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n\n  return ret;\n};\n\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function (opts) {\n  var buf, hex;\n\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = new Buffer(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = new Buffer(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = new Buffer([]);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\n\n\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\n\n\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.prototype.gt = function (b) {\n  return this.cmp(b) > 0;\n};\n\nBN.prototype.gte = function (b) {\n  return this.cmp(b) >= 0;\n};\n\nBN.prototype.lt = function (b) {\n  return this.cmp(b) < 0;\n};\n\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function (buf, natlen, size) {\n  var rbuf = new Buffer(size);\n\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n\n  return rbuf;\n};\n\nmodule.exports = BN;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/crypto/bn.js"],"names":["BN","require","$","_","reversebuf","buf","buf2","Buffer","length","i","Zero","One","Minus1","fromNumber","n","checkArgument","isNumber","fromString","str","base","isString","fromBuffer","opts","endian","hex","toString","bn","fromSM","ret","neg","copy","prototype","toNumber","parseInt","toBuffer","size","natlen","trim","pad","toSMBigEndian","cmp","concat","toSM","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","Error","toScriptNumBuffer","gt","b","gte","lt","slice","rbuf","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar reversebuf = function(buf) {\n  var buf2 = new Buffer(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(new Buffer([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = new Buffer(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = new Buffer(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = new Buffer([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.prototype.gt = function(b) {\n  return this.cmp(b) > 0;\n};\n\nBN.prototype.gte = function(b) {\n  return this.cmp(b) >= 0;\n};\n\nBN.prototype.lt = function(b) {\n  return this.cmp(b) < 0;\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = new Buffer(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n"]},"metadata":{},"sourceType":"script"}