{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\n\nvar Opcode = require('../opcode');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar Signature = require('../crypto/signature');\n\nvar PublicKey = require('../publickey');\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\n\n\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n *\n * Translated from bitcoind's VerifyScript\n */\n\n\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags) {\n  var Transaction = require('../transaction');\n\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  } // evaluate scriptSig\n\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  }); // evaluate scriptPubkey\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  } // Additional validation for spend-to-script-hash transactions:\n\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    } // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n\n\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    }); // evaluate redeemScript\n\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function (obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = new Buffer([1]);\nInterpreter.false = new Buffer([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n\nInterpreter.SCRIPT_VERIFY_NONE = 0; // Evaluate P2SH subscripts (softfork safe, BIP16).\n\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0; // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\n\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1; // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\n\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2; // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\n\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3; // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\n\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4; // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\n\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5; // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\n\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6; // Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7; // CLTV See BIP65 for details.\n\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;\n\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\n\n\nInterpreter.prototype.checkSignatureEncoding = function (buf) {\n  var sig;\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\n\n\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n\n      if (!fSuccess) {\n        return false;\n      }\n    } // Size limits\n\n\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\n\n\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n\n\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  } // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n\n\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n};\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.step = function () {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess; // Read instruction\n\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  } // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n\n\n  if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n  if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n      //\n      // Control\n      //\n\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n\n\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP3:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = this.stack.pop();\n            fValue = Interpreter.castToBool(buf);\n\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n          }\n\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n      //\n      // Stack ops\n      //\n\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - n - 1];\n\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n      //\n      // Bitwise logic\n      //\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Numeric\n      //\n\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n\n              break;\n\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n            //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n            // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n\n            case Opcode.OP_BOOLAND:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n\n            case Opcode.OP_BOOLOR:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n\n            case Opcode.OP_MIN:\n              bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n              break;\n\n            case Opcode.OP_MAX:\n              bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n              break;\n            // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal); //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n      //\n      // Crypto\n      //\n\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = this.stack[this.stack.length - 1]; //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n\n          var bufHash;\n\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1]; // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signature, since there's no way for a signature to sign itself\n\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          this.stack.pop();\n          this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n          var i = 1;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n\n          this.nOpCount += nKeysCount;\n\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          } // int ikey = ++i;\n\n\n          var ikey = ++i;\n          i += nKeysCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          } // int isig = ++i;\n\n\n          var isig = ++i;\n          i += nSigsCount;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signatures, since there's no way for a signature to sign itself\n\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig]; // valtype& vchPubKey = stacktop(-ikey);\n\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n\n            ikey++;\n            nKeysCount--; // If there are more signatures left than keys left,\n            // then too many signatures have failed\n\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          } // Clean up stack of actual arguments\n\n\n          while (i-- > 1) {\n            this.stack.pop();\n          } // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/lib/script/interpreter.js"],"names":["_","require","Script","Opcode","BN","Hash","Signature","PublicKey","Interpreter","obj","initialize","set","prototype","verify","scriptSig","scriptPubkey","tx","nin","flags","Transaction","isUndefined","script","stackCopy","SCRIPT_VERIFY_SIGPUSHONLY","isPushOnly","errstr","evaluate","SCRIPT_VERIFY_P2SH","stack","slice","length","buf","castToBool","isScriptHashOut","Error","redeemScriptSerialized","redeemScript","fromBuffer","pop","module","exports","altstack","pc","pbegincodehash","nOpCount","vfExec","altack","true","Buffer","false","MAX_SCRIPT_ELEMENT_SIZE","LOCKTIME_THRESHOLD","LOCKTIME_THRESHOLD_BN","SCRIPT_VERIFY_NONE","SCRIPT_VERIFY_STRICTENC","SCRIPT_VERIFY_DERSIG","SCRIPT_VERIFY_LOW_S","SCRIPT_VERIFY_NULLDUMMY","SCRIPT_VERIFY_MINIMALDATA","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS","SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY","i","checkSignatureEncoding","sig","isTxDER","fromTxFormat","hasLowS","hasDefinedHashtype","checkPubkeyEncoding","isValid","toBuffer","chunks","fSuccess","step","e","checkLockTime","nLockTime","lt","gte","gt","inputs","isFinal","fRequireMinimal","fExec","indexOf","buf1","buf2","spliced","n","x1","x2","bn","bn1","bn2","bufSig","bufPubkey","subscript","pubkey","fValue","chunk","opcodenum","OP_16","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_INVERT","OP_AND","OP_OR","OP_XOR","OP_2MUL","OP_2DIV","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_PUSHDATA4","checkMinimalPush","push","len","OP_IF","OP_ENDIF","OP_1NEGATE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","toScriptNumBuffer","OP_NOP","OP_NOP2","OP_CHECKLOCKTIMEVERIFY","fromScriptNumBuffer","OP_NOP1","OP_NOP3","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_NOTIF","OP_ELSE","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","buf3","OP_2OVER","OP_2ROT","splice","OP_2SWAP","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","toNumber","OP_ROT","x3","OP_SWAP","OP_TUCK","OP_SIZE","OP_EQUAL","OP_EQUALVERIFY","fEqual","toString","OP_1ADD","OP_1SUB","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","add","One","sub","neg","cmp","Zero","OP_ADD","OP_SUB","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","OP_WITHIN","bn3","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","bufHash","ripemd160","sha1","sha256","sha256ripemd160","sha256sha256","OP_CODESEPARATOR","OP_CHECKSIG","OP_CHECKSIGVERIFY","tmpScript","findAndDelete","verifySignature","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","nKeysCount","ikey","nSigsCount","isig","k","fOk"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\nvar Opcode = require('../opcode');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar Signature = require('../crypto/signature');\nvar PublicKey = require('../publickey');\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags) {\n  var Transaction = require('../transaction');\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = new Buffer([1]);\nInterpreter.false = new Buffer([]);\n\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n// CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\n  var sig;\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n  return true;\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n\n    // Size limits\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n\n  if (opcodenum === Opcode.OP_CAT ||\n    opcodenum === Opcode.OP_SUBSTR ||\n    opcodenum === Opcode.OP_LEFT ||\n    opcodenum === Opcode.OP_RIGHT ||\n    opcodenum === Opcode.OP_INVERT ||\n    opcodenum === Opcode.OP_AND ||\n    opcodenum === Opcode.OP_OR ||\n    opcodenum === Opcode.OP_XOR ||\n    opcodenum === Opcode.OP_2MUL ||\n    opcodenum === Opcode.OP_2DIV ||\n    opcodenum === Opcode.OP_MUL ||\n    opcodenum === Opcode.OP_DIV ||\n    opcodenum === Opcode.OP_MOD ||\n    opcodenum === Opcode.OP_LSHIFT ||\n    opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP3:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n            buf = this.stack.pop();\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n\n        //\n        // Bitwise logic\n        //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signature, since there's no way for a signature to sign itself\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};\n\n"]},"metadata":{},"sourceType":"script"}