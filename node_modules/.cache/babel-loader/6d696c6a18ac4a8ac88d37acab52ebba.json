{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar Address = require('./address');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar BN = require('./crypto/bn');\n\nvar JSUtil = require('./util/js');\n\nvar Networks = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PublicKey = require('./publickey');\n\nvar Random = require('./crypto/random');\n\nvar $ = require('./util/preconditions');\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\n\n\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n\n  /* jshint maxcomplexity: 8 */\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network); // validation\n\n\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0) {\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n\n  if (typeof info.network === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n  return this;\n}\n\n;\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\n\nPrivateKey.prototype._classifyArguments = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  }; // detect type of data\n\n  if (_.isUndefined(data) || _.isNull(data)) {\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network) {\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof data === 'string') {\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(new Buffer(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n\n  return info;\n};\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\n\n\nPrivateKey._getRandomBN = function () {\n  var condition;\n  var bn;\n\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n\n  return bn;\n};\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformBuffer = function (buf, network) {\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n  return info;\n};\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\n\n\nPrivateKey._transformBNBuffer = function (buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformWIF = function (str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\n\n\nPrivateKey.fromBuffer = function (arg, network) {\n  return new PrivateKey(arg, network);\n};\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\n\n\nPrivateKey._transformObject = function (json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromString = PrivateKey.fromWIF = function (str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\n\n\nPrivateKey.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\n\n\nPrivateKey.fromRandom = function (network) {\n  var bn = PrivateKey._getRandomBN();\n\n  return new PrivateKey(bn, network);\n};\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\n\nPrivateKey.getValidationError = function (data, network) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\n\n\nPrivateKey.isValid = function (data, network) {\n  if (!data) {\n    return false;\n  }\n\n  return !PrivateKey.getValidationError(data, network);\n};\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\n\n\nPrivateKey.prototype.toString = function () {\n  return this.toBuffer().toString('hex');\n};\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\n\n\nPrivateKey.prototype.toWIF = function () {\n  var network = this.network;\n  var compressed = this.compressed;\n  var buf;\n\n  if (compressed) {\n    buf = Buffer.concat([new Buffer([network.privatekey]), this.bn.toBuffer({\n      size: 32\n    }), new Buffer([0x01])]);\n  } else {\n    buf = Buffer.concat([new Buffer([network.privatekey]), this.bn.toBuffer({\n      size: 32\n    })]);\n  }\n\n  return Base58Check.encode(buf);\n};\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\n\n\nPrivateKey.prototype.toBigNumber = function () {\n  return this.bn;\n};\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\n\n\nPrivateKey.prototype.toBuffer = function () {\n  return this.bn.toBuffer();\n};\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\n\n\nPrivateKey.prototype.toPublicKey = function () {\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n\n  return this._pubkey;\n};\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\n\n\nPrivateKey.prototype.toAddress = function (network) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network);\n};\n/**\n * @returns {Object} A plain object representation\n */\n\n\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\n\n\nPrivateKey.prototype.inspect = function () {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/lib/privatekey.js"],"names":["_","require","Address","Base58Check","BN","JSUtil","Networks","Point","PublicKey","Random","$","PrivateKey","data","network","info","_classifyArguments","bn","cmp","TypeError","lt","getN","defineImmutable","compressed","Object","defineProperty","configurable","enumerable","get","toPublicKey","bind","prototype","defaultNetwork","isUndefined","isNull","_getRandomBN","Buffer","Uint8Array","_transformBuffer","_transformObject","isHexa","_transformWIF","condition","privbuf","getRandomBuffer","fromBuffer","buf","length","_transformBNBuffer","Error","slice","str","decode","arg","json","fromString","fromWIF","checkArgument","isString","fromObject","obj","isObject","fromRandom","getValidationError","error","e","isValid","toString","toBuffer","toWIF","concat","privatekey","size","encode","toBigNumber","_pubkey","fromPrivateKey","toAddress","pubkey","fromPublicKey","toObject","toJSON","inspect","uncompressed","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar Address = require('./address');\nvar Base58Check = require('./encoding/base58check');\nvar BN = require('./crypto/bn');\nvar JSUtil = require('./util/js');\nvar Networks = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\nvar Random = require('./crypto/random');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PrivateKey from a BN, Buffer and WIF.\n *\n * @example\n * ```javascript\n * // generate a new random key\n * var key = PrivateKey();\n *\n * // get the associated address\n * var address = key.toAddress();\n *\n * // encode into wallet export format\n * var exported = key.toWIF();\n *\n * // instantiate from the exported (and saved) private key\n * var imported = PrivateKey.fromWIF(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {PrivateKey} A new valid instance of an PrivateKey\n * @constructor\n */\nfunction PrivateKey(data, network) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 8 */\n\n  if (!(this instanceof PrivateKey)) {\n    return new PrivateKey(data, network);\n  }\n  if (data instanceof PrivateKey) {\n    return data;\n  }\n\n  var info = this._classifyArguments(data, network);\n\n  // validation\n  if (!info.bn || info.bn.cmp(new BN(0)) === 0){\n    throw new TypeError('Number can not be equal to zero, undefined, null or false');\n  }\n  if (!info.bn.lt(Point.getN())) {\n    throw new TypeError('Number must be less than N');\n  }\n  if (typeof(info.network) === 'undefined') {\n    throw new TypeError('Must specify the network (\"livenet\" or \"testnet\")');\n  }\n\n  JSUtil.defineImmutable(this, {\n    bn: info.bn,\n    compressed: info.compressed,\n    network: info.network\n  });\n\n  Object.defineProperty(this, 'publicKey', {\n    configurable: false,\n    enumerable: true,\n    get: this.toPublicKey.bind(this)\n  });\n\n  return this;\n\n};\n\n/**\n * Internal helper to instantiate PrivateKey internal `info` object from\n * different kinds of arguments passed to the constructor.\n *\n * @param {*} data\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @return {Object}\n */\nPrivateKey.prototype._classifyArguments = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: true,\n    network: network ? Networks.get(network) : Networks.defaultNetwork\n  };\n\n  // detect type of data\n  if (_.isUndefined(data) || _.isNull(data)){\n    info.bn = PrivateKey._getRandomBN();\n  } else if (data instanceof BN) {\n    info.bn = data;\n  } else if (data instanceof Buffer || data instanceof Uint8Array) {\n    info = PrivateKey._transformBuffer(data, network);\n  } else if (data.bn && data.network){\n    info = PrivateKey._transformObject(data);\n  } else if (!network && Networks.get(data)) {\n    info.bn = PrivateKey._getRandomBN();\n    info.network = Networks.get(data);\n  } else if (typeof(data) === 'string'){\n    if (JSUtil.isHexa(data)) {\n      info.bn = new BN(new Buffer(data, 'hex'));\n    } else {\n      info = PrivateKey._transformWIF(data, network);\n    }\n  } else {\n    throw new TypeError('First argument is an unrecognized data type.');\n  }\n  return info;\n};\n\n/**\n * Internal function to get a random Big Number (BN)\n *\n * @returns {BN} A new randomly generated BN\n * @private\n */\nPrivateKey._getRandomBN = function(){\n  var condition;\n  var bn;\n  do {\n    var privbuf = Random.getRandomBuffer(32);\n    bn = BN.fromBuffer(privbuf);\n    condition = bn.lt(Point.getN());\n  } while (!condition);\n  return bn;\n};\n\n/**\n * Internal function to transform a WIF Buffer into a private key\n *\n * @param {Buffer} buf - An WIF string\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformBuffer = function(buf, network) {\n\n  var info = {};\n\n  if (buf.length === 32) {\n    return PrivateKey._transformBNBuffer(buf, network);\n  }\n\n  info.network = Networks.get(buf[0], 'privatekey');\n\n  if (!info.network) {\n    throw new Error('Invalid network');\n  }\n\n  if (network && info.network !== Networks.get(network)) {\n    throw new TypeError('Private key network mismatch');\n  }\n\n  if (buf.length === 1 + 32 + 1 && buf[1 + 32 + 1 - 1] === 1) {\n    info.compressed = true;\n  } else if (buf.length === 1 + 32) {\n    info.compressed = false;\n  } else {\n    throw new Error('Length of buffer must be 33 (uncompressed) or 34 (compressed)');\n  }\n\n  info.bn = BN.fromBuffer(buf.slice(1, 32 + 1));\n\n  return info;\n};\n\n/**\n * Internal function to transform a BN buffer into a private key\n *\n * @param {Buffer} buf\n * @param {Network|string=} network - a {@link Network} object, or a string with the network name\n * @returns {object} an Object with keys: bn, network, and compressed\n * @private\n */\nPrivateKey._transformBNBuffer = function(buf, network) {\n  var info = {};\n  info.network = Networks.get(network) || Networks.defaultNetwork;\n  info.bn = BN.fromBuffer(buf);\n  info.compressed = false;\n  return info;\n};\n\n/**\n * Internal function to transform a WIF string into a private key\n *\n * @param {string} buf - An WIF string\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformWIF = function(str, network) {\n  return PrivateKey._transformBuffer(Base58Check.decode(str), network);\n};\n\n/**\n * Instantiate a PrivateKey from a Buffer with the DER or WIF representation\n *\n * @param {Buffer} arg\n * @param {Network} network\n * @return {PrivateKey}\n */\nPrivateKey.fromBuffer = function(arg, network) {\n  return new PrivateKey(arg, network);\n};\n\n/**\n * Internal function to transform a JSON string on plain object into a private key\n * return this.\n *\n * @param {string} json - A JSON string or plain object\n * @returns {Object} An object with keys: bn, network and compressed\n * @private\n */\nPrivateKey._transformObject = function(json) {\n  var bn = new BN(json.bn, 'hex');\n  var network = Networks.get(json.network);\n  return {\n    bn: bn,\n    network: network,\n    compressed: json.compressed\n  };\n};\n\n/**\n * Instantiate a PrivateKey from a WIF string\n *\n * @param {string} str - The WIF encoded private key string\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromString = PrivateKey.fromWIF = function(str) {\n  $.checkArgument(_.isString(str), 'First argument is expected to be a string.');\n  return new PrivateKey(str);\n};\n\n/**\n * Instantiate a PrivateKey from a plain JavaScript object\n *\n * @param {Object} obj - The output from privateKey.toObject()\n */\nPrivateKey.fromObject = function(obj) {\n  $.checkArgument(_.isObject(obj), 'First argument is expected to be an object.');\n  return new PrivateKey(obj);\n};\n\n/**\n * Instantiate a PrivateKey from random bytes\n *\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {PrivateKey} A new valid instance of PrivateKey\n */\nPrivateKey.fromRandom = function(network) {\n  var bn = PrivateKey._getRandomBN();\n  return new PrivateKey(bn, network);\n};\n\n/**\n * Check if there would be any errors when initializing a PrivateKey\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {null|Error} An error if exists\n */\n\nPrivateKey.getValidationError = function(data, network) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PrivateKey(data, network);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @param {string=} network - Either \"livenet\" or \"testnet\"\n * @returns {Boolean} If the private key is would be valid\n */\nPrivateKey.isValid = function(data, network){\n  if (!data) {\n    return false;\n  }\n  return !PrivateKey.getValidationError(data, network);\n};\n\n/**\n * Will output the PrivateKey encoded as hex string\n *\n * @returns {string}\n */\nPrivateKey.prototype.toString = function() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * Will output the PrivateKey to a WIF string\n *\n * @returns {string} A WIP representation of the private key\n */\nPrivateKey.prototype.toWIF = function() {\n  var network = this.network;\n  var compressed = this.compressed;\n\n  var buf;\n  if (compressed) {\n    buf = Buffer.concat([new Buffer([network.privatekey]),\n                         this.bn.toBuffer({size: 32}),\n                         new Buffer([0x01])]);\n  } else {\n    buf = Buffer.concat([new Buffer([network.privatekey]),\n                         this.bn.toBuffer({size: 32})]);\n  }\n\n  return Base58Check.encode(buf);\n};\n\n/**\n * Will return the private key as a BN instance\n *\n * @returns {BN} A BN instance of the private key\n */\nPrivateKey.prototype.toBigNumber = function(){\n  return this.bn;\n};\n\n/**\n * Will return the private key as a BN buffer\n *\n * @returns {Buffer} A buffer of the private key\n */\nPrivateKey.prototype.toBuffer = function(){\n  return this.bn.toBuffer();\n};\n\n/**\n * Will return the corresponding public key\n *\n * @returns {PublicKey} A public key generated from the private key\n */\nPrivateKey.prototype.toPublicKey = function(){\n  if (!this._pubkey) {\n    this._pubkey = PublicKey.fromPrivateKey(this);\n  }\n  return this._pubkey;\n};\n\n/**\n * Will return an address for the private key\n * @param {Network=} network - optional parameter specifying\n * the desired network for the address\n *\n * @returns {Address} An address generated from the private key\n */\nPrivateKey.prototype.toAddress = function(network) {\n  var pubkey = this.toPublicKey();\n  return Address.fromPublicKey(pubkey, network || this.network);\n};\n\n/**\n * @returns {Object} A plain object representation\n */\nPrivateKey.prototype.toObject = PrivateKey.prototype.toJSON = function toObject() {\n  return {\n    bn: this.bn.toString('hex'),\n    compressed: this.compressed,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Private key\n */\nPrivateKey.prototype.inspect = function() {\n  var uncompressed = !this.compressed ? ', uncompressed' : '';\n  return '<PrivateKey: ' + this.toString() + ', network: ' + this.network + uncompressed + '>';\n};\n\nmodule.exports = PrivateKey;\n"]},"metadata":{},"sourceType":"script"}