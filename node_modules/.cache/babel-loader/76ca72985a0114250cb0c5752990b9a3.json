{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n/* jshint maxcomplexity: 7 */\n\n\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; //whether the recovered pubkey is compressed\n\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function (buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n}; // The format used in a tx\n\n\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function (str) {\n  var buf = new Buffer(str, 'hex');\n  return Signature.fromDER(buf);\n};\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\n\n\nSignature.parseDER = function (buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n  return obj;\n};\n\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n\n  if (compressed === false) {\n    val = val - 4;\n  }\n\n  var b1 = new Buffer([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function () {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n  var rbuf = rneg ? Buffer.concat([new Buffer([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([new Buffer([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([new Buffer([header, length, rheader, rlength]), rbuf, new Buffer([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\n\n\nSignature.isTxDER = function (buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n\n  var nLenR = buf[3];\n\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n\n  var nLenS = buf[5 + nLenR];\n\n  if (nLenR + nLenS + 7 !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n\n  if (nLenR > 1 && R[0] === 0x00 && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n\n  if (nLenS > 1 && S[0] === 0x00 && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n\n  return true;\n};\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\n\n\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\n\n\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n\n\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n\n  return true;\n};\n\nSignature.prototype.toTxFormat = function () {\n  var derbuf = this.toDER();\n  var buf = new Buffer(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\nmodule.exports = Signature;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/crypto/signature.js"],"names":["BN","require","_","$","BufferUtil","JSUtil","Signature","r","s","set","obj","prototype","undefined","i","compressed","nhashtype","fromCompact","buf","checkArgument","isBuffer","sig","slice","b2","b3","Error","length","fromBuffer","fromDER","strict","parseDER","fromTxFormat","readUInt8","derbuf","fromString","str","Buffer","isUndefined","header","buflength","rheader","rlength","rbuf","rneg","sheader","slength","sbuf","sneg","sumlength","toCompact","val","b1","toBuffer","size","concat","toDER","rnbuf","snbuf","der","toString","isTxDER","nLenR","nLenS","R","S","hasLowS","lt","gt","hasDefinedHashtype","isNaturalNumber","temp","SIGHASH_ANYONECANPAY","SIGHASH_ALL","SIGHASH_SINGLE","toTxFormat","writeUInt8","SIGHASH_NONE","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s);\n  }\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 7 */\nSignature.prototype.set = function(obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n  this.compressed = typeof obj.compressed !== 'undefined' ?\n    obj.compressed : this.compressed; //whether the recovered pubkey is compressed\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function(buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n\n  var sig = new Signature();\n\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function(buf, strict) {\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n\n  sig.r = obj.r;\n  sig.s = obj.s;\n\n  return sig;\n};\n\n// The format used in a tx\nSignature.fromTxFormat = function(buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n};\n\nSignature.fromString = function(str) {\n  var buf = new Buffer(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\n\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\nSignature.parseDER = function(buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n\n  length = length < buflength ? length : buflength;\n\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n\n  return obj;\n};\n\n\nSignature.prototype.toCompact = function(i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n  if (compressed === false) {\n    val = val - 4;\n  }\n  var b1 = new Buffer([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function() {\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n\n  var rbuf = rneg ? Buffer.concat([new Buffer([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([new Buffer([0x00]), snbuf]) : snbuf;\n\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n\n  var der = Buffer.concat([new Buffer([header, length, rheader, rlength]), rbuf, new Buffer([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function() {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S] [hashtype]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\nSignature.isTxDER = function(buf) {\n  if (buf.length < 9) {\n    //  Non-canonical signature: too short\n    return false;\n  }\n  if (buf.length > 73) {\n    // Non-canonical signature: too long\n    return false;\n  }\n  if (buf[0] !== 0x30) {\n    //  Non-canonical signature: wrong type\n    return false;\n  }\n  if (buf[1] !== buf.length - 3) {\n    //  Non-canonical signature: wrong length marker\n    return false;\n  }\n  var nLenR = buf[3];\n  if (5 + nLenR >= buf.length) {\n    //  Non-canonical signature: S length misplaced\n    return false;\n  }\n  var nLenS = buf[5 + nLenR];\n  if ((nLenR + nLenS + 7) !== buf.length) {\n    //  Non-canonical signature: R+S length mismatch\n    return false;\n  }\n\n  var R = buf.slice(4);\n  if (buf[4 - 2] !== 0x02) {\n    //  Non-canonical signature: R value type mismatch\n    return false;\n  }\n  if (nLenR === 0) {\n    //  Non-canonical signature: R length is zero\n    return false;\n  }\n  if (R[0] & 0x80) {\n    //  Non-canonical signature: R value negative\n    return false;\n  }\n  if (nLenR > 1 && (R[0] === 0x00) && !(R[1] & 0x80)) {\n    //  Non-canonical signature: R value excessively padded\n    return false;\n  }\n\n  var S = buf.slice(6 + nLenR);\n  if (buf[6 + nLenR - 2] !== 0x02) {\n    //  Non-canonical signature: S value type mismatch\n    return false;\n  }\n  if (nLenS === 0) {\n    //  Non-canonical signature: S length is zero\n    return false;\n  }\n  if (S[0] & 0x80) {\n    //  Non-canonical signature: S value negative\n    return false;\n  }\n  if (nLenS > 1 && (S[0] === 0x00) && !(S[1] & 0x80)) {\n    //  Non-canonical signature: S value excessively padded\n    return false;\n  }\n  return true;\n};\n\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\nSignature.prototype.hasLowS = function() {\n  if (this.s.lt(new BN(1)) ||\n    this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\nSignature.prototype.hasDefinedHashtype = function() {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  }\n  // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  var temp = this.nhashtype & ~Signature.SIGHASH_ANYONECANPAY;\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n  return true;\n};\n\nSignature.prototype.toTxFormat = function() {\n  var derbuf = this.toDER();\n  var buf = new Buffer(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\n\nmodule.exports = Signature;\n"]},"metadata":{},"sourceType":"script"}