{"ast":null,"code":"'use strict';\n\nvar bitcore = require('bitcore-lib-litecoin');\n\nvar BN = bitcore.crypto.BN;\n\nvar unorm = require('unorm');\n\nvar _ = bitcore.deps._;\n\nvar pbkdf2 = require('./pbkdf2');\n\nvar errors = require('./errors');\n\nvar Hash = bitcore.crypto.Hash;\nvar Random = bitcore.crypto.Random;\nvar $ = bitcore.util.preconditions;\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\n\nvar Mnemonic = function Mnemonic(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  } // handle data overloading\n\n\n  var ent, phrase, seed;\n\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new bitcore.errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n\n  ent = ent || 128; // check and detect wordlist\n\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  } // validate phrase and ent\n\n\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n\n  if (ent % 32 !== 0 || ent < 128) {\n    throw new bitcore.errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT % 32 == 0');\n  }\n\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\n\nMnemonic.Words = require('./words');\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\n\nMnemonic.isValid = function (mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n\n  if (!wordlist) {\n    return false;\n  }\n\n  var words = mnemonic.split(' ');\n  var bin = '';\n\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = new Buffer(nonhash_bits.length / 8);\n\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n\n  return expected_hash_bits === hash_bits;\n};\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\n\n\nMnemonic._belongsToWordlist = function (mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n\n  return true;\n};\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\n\n\nMnemonic._getDictionary = function (mnemonic) {\n  if (!mnemonic) return null;\n  var dicts = Object.keys(Mnemonic.Words);\n\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n\n  return null;\n};\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\n\n\nMnemonic.prototype.toSeed = function (passphrase) {\n  passphrase = passphrase || '';\n  return pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\n\n\nMnemonic.fromSeed = function (seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\n\n\nMnemonic.prototype.toHDPrivateKey = function (passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return bitcore.HDPrivateKey.fromSeed(seed, network);\n};\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\n\n\nMnemonic.prototype.toString = function () {\n  return this.phrase;\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\n\n\nMnemonic.prototype.inspect = function () {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\n\n\nMnemonic._mnemonic = function (ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Number} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\n\n\nMnemonic._entropy2mnemonic = function (entropy, wordlist) {\n  var bin = '';\n\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n\n  var mnemonic = [];\n\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n\n  var ret;\n\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join(\"\\u3000\");\n  } else {\n    ret = mnemonic.join(' ');\n  }\n\n  return ret;\n};\n/**\n * Internal function to create checksum of entropy\n *\n * @param entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\n\n\nMnemonic._entropyChecksum = function (entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2); // zero pad the hash bits\n\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n\n  var checksum = hashbits.slice(0, cs);\n  return checksum;\n};\n\nmodule.exports = Mnemonic;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-mnemonic-litecoin/lib/mnemonic.js"],"names":["bitcore","require","BN","crypto","unorm","_","deps","pbkdf2","errors","Hash","Random","$","util","preconditions","Mnemonic","data","wordlist","isArray","ent","phrase","seed","Buffer","isBuffer","isString","nfkd","isNumber","InvalidArgument","_getDictionary","UnknownWordlist","Words","ENGLISH","_entropy2mnemonic","isValid","InvalidMnemonic","_mnemonic","Object","defineProperty","configurable","value","mnemonic","words","split","bin","i","length","ind","indexOf","toString","slice","cs","hash_bits","nonhash_bits","buf","writeUInt8","parseInt","expected_hash_bits","_entropyChecksum","_belongsToWordlist","dicts","keys","key","prototype","toSeed","passphrase","fromSeed","checkArgument","toHDPrivateKey","network","HDPrivateKey","inspect","ENT","getRandomBuffer","entropy","InvalidEntropy","wi","push","ret","JAPANESE","join","hash","sha256","bits","hashbits","checksum","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar bitcore = require('bitcore-lib-litecoin')\nvar BN = bitcore.crypto.BN;\nvar unorm = require('unorm');\nvar _ = bitcore.deps._;\n\nvar pbkdf2 = require('./pbkdf2');\nvar errors = require('./errors');\n\nvar Hash = bitcore.crypto.Hash;\nvar Random = bitcore.crypto.Random;\n\nvar $ = bitcore.util.preconditions;\n\n\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\nvar Mnemonic = function(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  }\n\n\n  // handle data overloading\n  var ent, phrase, seed;\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new bitcore.errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n  ent = ent || 128;\n\n\n  // check and detect wordlist\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  }\n\n\n  // validate phrase and ent\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n  if (ent % 32 !== 0 || ent < 128) {\n    throw new bitcore.errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT % 32 == 0');\n  }\n\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\n\nMnemonic.Words = require('./words');\n\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\nMnemonic.isValid = function(mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n\n  if (!wordlist) {\n    return false;\n  }\n\n  var words = mnemonic.split(' ');\n  var bin = '';\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = new Buffer(nonhash_bits.length / 8);\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n  return expected_hash_bits === hash_bits;\n};\n\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\nMnemonic._belongsToWordlist = function(mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n  return true;\n};\n\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\nMnemonic._getDictionary = function(mnemonic) {\n  if (!mnemonic) return null;\n\n  var dicts = Object.keys(Mnemonic.Words);\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n  return null;\n};\n\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\nMnemonic.prototype.toSeed = function(passphrase) {\n  passphrase = passphrase || '';\n  return pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\nMnemonic.fromSeed = function(seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\nMnemonic.prototype.toHDPrivateKey = function(passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return bitcore.HDPrivateKey.fromSeed(seed, network);\n};\n\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.toString = function() {\n  return this.phrase;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.inspect = function() {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._mnemonic = function(ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Number} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._entropy2mnemonic = function(entropy, wordlist) {\n  var bin = '';\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n  var mnemonic = [];\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n  var ret;\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n  return ret;\n};\n\n/**\n * Internal function to create checksum of entropy\n *\n * @param entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\nMnemonic._entropyChecksum = function(entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2);\n\n  // zero pad the hash bits\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n\n  var checksum = hashbits.slice(0, cs);\n\n  return checksum;\n};\n\nmodule.exports = Mnemonic;\n"]},"metadata":{},"sourceType":"script"}