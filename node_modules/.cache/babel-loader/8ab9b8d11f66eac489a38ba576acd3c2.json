{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar buffer = require('buffer');\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar Network = require('./networks');\n\nvar HDKeyCache = require('./hdkeycache');\n\nvar Point = require('./crypto/point');\n\nvar PrivateKey = require('./privatekey');\n\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\n\nvar hdErrors = errors.HDPrivateKey;\n\nvar BufferUtil = require('./util/buffer');\n\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\n\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidPath = function (arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.all(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\n\n\nHDPrivateKey._getDerivationIndexes = function (path) {\n  var steps = path.split('/'); // Special cases:\n\n  if (_.contains(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.contains(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function (step) {\n    var isHardened = step.slice(-1) === '\\'';\n\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n\n    var index = +step; // cast to number\n\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n  return _.any(indexes, isNaN) ? null : indexes;\n};\n/**\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\n\n\nHDPrivateKey.prototype.derive = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function (index, hardened) {\n  /* jshint maxstatements: 20 */\n\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var cached = HDKeyCache.get(this.xprivkey, index, hardened);\n\n  if (cached) {\n    return cached;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n\n  if (hardened) {\n    data = BufferUtil.concat([new buffer.Buffer([0]), this.privateKey.toBuffer(), indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).mod(Point.getN()).toBuffer({\n    size: 32\n  });\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n  HDKeyCache.set(this.xprivkey, index, hardened, derived);\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function (path) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPrivateKey.isValidSerialized = function (data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\n\n\nHDPrivateKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(0, 4);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPrivateKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function (arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,\n    checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function (network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\n\n\nHDPrivateKey.fromSeed = function (hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = BufferUtil.hexToBuffer(hexa);\n  }\n\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n\n  var hash = Hash.sha512hmac(hexa, new buffer.Buffer('Bitcoin seed'));\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\nHDPrivateKey.prototype._calcHDPublicKey = function () {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\n\n\nHDPrivateKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey];\n  var concat = buffer.Buffer.concat(sequence);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = new Buffer(xprivkey);\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  this._hdPublicKey = null;\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function () {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function () {\n      this._calcHDPublicKey();\n\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function (name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\n\n\nHDPrivateKey.prototype.toString = function () {\n  return this.xprivkey;\n};\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\n\n\nHDPrivateKey.prototype.inspect = function () {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\n\n\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\n\n\nHDPrivateKey.fromBuffer = function (arg) {\n  return new HDPrivateKey(arg.toString());\n};\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\n\n\nHDPrivateKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\nmodule.exports = HDPrivateKey;","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/lib/hdprivatekey.js"],"names":["assert","require","buffer","_","$","BN","Base58","Base58Check","Hash","Network","HDKeyCache","Point","PrivateKey","Random","errors","hdErrors","HDPrivateKey","BufferUtil","JSUtil","MINIMUM_ENTROPY_BITS","BITS_TO_BYTES","MAXIMUM_ENTROPY_BITS","arg","_generateRandomly","get","isString","isBuffer","isValidSerialized","_buildFromSerialized","isValidJSON","_buildFromJSON","toString","getSerializedError","isObject","_buildFromObject","UnrecognizedArgument","isValidPath","hardened","indexes","_getDerivationIndexes","all","isNumber","Hardened","MaxIndex","path","steps","split","contains","RootElementAlias","slice","map","step","isHardened","NaN","index","any","isNaN","prototype","derive","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","InvalidPath","cached","xprivkey","indexBuffer","integerAsBuffer","data","concat","Buffer","privateKey","toBuffer","publicKey","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","size","add","toBigNumber","mod","getN","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","set","reduce","prev","validCharacters","InvalidB58Char","decode","e","InvalidB58Checksum","length","DataLength","InvalidLength","isUndefined","error","_validateNetwork","networkArg","InvalidNetworkArgument","version","integerFromBuffer","InvalidNetwork","fromString","checkArgument","fromObject","JSON","parse","buffers","integerAsSingleByteBuffer","hexToBuffer","isHexa","checksum","undefined","_buildFromBuffers","decoded","VersionStart","VersionEnd","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PrivateKeyStart","PrivateKeyEnd","ChecksumStart","ChecksumEnd","fromSeed","getRandomBuffer","hexa","isHexaString","InvalidEntropyArgument","NotEnoughEntropy","TooMuchEntropy","defaultNetwork","_calcHDPublicKey","_hdPublicKey","HDPublicKey","_validateBufferArguments","defineImmutable","sequence","emptyBuffer","encode","toPublicKey","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","Object","defineProperty","configurable","enumerable","xpubkey","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PrivateKeySize","CheckSumSize","inspect","toObject","toJSON","bufferToHex","copy","DefaultDepth","DefaultFingerprint","DefaultChildIndex","SerializedByteSize","module","exports"],"mappings":"AAAA;;AAGA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIE,CAAC,GAAGF,OAAO,CAAC,QAAD,CAAf;;AACA,IAAIG,CAAC,GAAGH,OAAO,CAAC,sBAAD,CAAf;;AAEA,IAAII,EAAE,GAAGJ,OAAO,CAAC,aAAD,CAAhB;;AACA,IAAIK,MAAM,GAAGL,OAAO,CAAC,mBAAD,CAApB;;AACA,IAAIM,WAAW,GAAGN,OAAO,CAAC,wBAAD,CAAzB;;AACA,IAAIO,IAAI,GAAGP,OAAO,CAAC,eAAD,CAAlB;;AACA,IAAIQ,OAAO,GAAGR,OAAO,CAAC,YAAD,CAArB;;AACA,IAAIS,UAAU,GAAGT,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIU,KAAK,GAAGV,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIW,UAAU,GAAGX,OAAO,CAAC,cAAD,CAAxB;;AACA,IAAIY,MAAM,GAAGZ,OAAO,CAAC,iBAAD,CAApB;;AAEA,IAAIa,MAAM,GAAGb,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIc,QAAQ,GAAGD,MAAM,CAACE,YAAtB;;AACA,IAAIC,UAAU,GAAGhB,OAAO,CAAC,eAAD,CAAxB;;AACA,IAAIiB,MAAM,GAAGjB,OAAO,CAAC,WAAD,CAApB;;AAEA,IAAIkB,oBAAoB,GAAG,GAA3B;AACA,IAAIC,aAAa,GAAG,IAAI,CAAxB;AACA,IAAIC,oBAAoB,GAAG,GAA3B;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASL,YAAT,CAAsBM,GAAtB,EAA2B;AACzB;AACA,MAAIA,GAAG,YAAYN,YAAnB,EAAiC;AAC/B,WAAOM,GAAP;AACD;;AACD,MAAI,EAAE,gBAAgBN,YAAlB,CAAJ,EAAqC;AACnC,WAAO,IAAIA,YAAJ,CAAiBM,GAAjB,CAAP;AACD;;AACD,MAAI,CAACA,GAAL,EAAU;AACR,WAAO,KAAKC,iBAAL,EAAP;AACD;;AAED,MAAId,OAAO,CAACe,GAAR,CAAYF,GAAZ,CAAJ,EAAsB;AACpB,WAAO,KAAKC,iBAAL,CAAuBD,GAAvB,CAAP;AACD,GAFD,MAEO,IAAInB,CAAC,CAACsB,QAAF,CAAWH,GAAX,KAAmBL,UAAU,CAACS,QAAX,CAAoBJ,GAApB,CAAvB,EAAiD;AACtD,QAAIN,YAAY,CAACW,iBAAb,CAA+BL,GAA/B,CAAJ,EAAyC;AACvC,WAAKM,oBAAL,CAA0BN,GAA1B;AACD,KAFD,MAEO,IAAIJ,MAAM,CAACW,WAAP,CAAmBP,GAAnB,CAAJ,EAA6B;AAClC,WAAKQ,cAAL,CAAoBR,GAApB;AACD,KAFM,MAEA,IAAIL,UAAU,CAACS,QAAX,CAAoBJ,GAApB,KAA4BN,YAAY,CAACW,iBAAb,CAA+BL,GAAG,CAACS,QAAJ,EAA/B,CAAhC,EAAgF;AACrF,WAAKH,oBAAL,CAA0BN,GAAG,CAACS,QAAJ,EAA1B;AACD,KAFM,MAEA;AACL,YAAMf,YAAY,CAACgB,kBAAb,CAAgCV,GAAhC,CAAN;AACD;AACF,GAVM,MAUA,IAAInB,CAAC,CAAC8B,QAAF,CAAWX,GAAX,CAAJ,EAAqB;AAC1B,SAAKY,gBAAL,CAAsBZ,GAAtB;AACD,GAFM,MAEA;AACL,UAAM,IAAIP,QAAQ,CAACoB,oBAAb,CAAkCb,GAAlC,CAAN;AACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,YAAY,CAACoB,WAAb,GAA2B,UAASd,GAAT,EAAce,QAAd,EAAwB;AACjD,MAAIlC,CAAC,CAACsB,QAAF,CAAWH,GAAX,CAAJ,EAAqB;AACnB,QAAIgB,OAAO,GAAGtB,YAAY,CAACuB,qBAAb,CAAmCjB,GAAnC,CAAd;;AACA,WAAOgB,OAAO,KAAK,IAAZ,IAAoBnC,CAAC,CAACqC,GAAF,CAAMF,OAAN,EAAetB,YAAY,CAACoB,WAA5B,CAA3B;AACD;;AAED,MAAIjC,CAAC,CAACsC,QAAF,CAAWnB,GAAX,CAAJ,EAAqB;AACnB,QAAIA,GAAG,GAAGN,YAAY,CAAC0B,QAAnB,IAA+BL,QAAQ,KAAK,IAAhD,EAAsD;AACpDf,MAAAA,GAAG,IAAIN,YAAY,CAAC0B,QAApB;AACD;;AACD,WAAOpB,GAAG,IAAI,CAAP,IAAYA,GAAG,GAAGN,YAAY,CAAC2B,QAAtC;AACD;;AAED,SAAO,KAAP;AACD,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3B,YAAY,CAACuB,qBAAb,GAAqC,UAASK,IAAT,EAAe;AAClD,MAAIC,KAAK,GAAGD,IAAI,CAACE,KAAL,CAAW,GAAX,CAAZ,CADkD,CAGlD;;AACA,MAAI3C,CAAC,CAAC4C,QAAF,CAAW/B,YAAY,CAACgC,gBAAxB,EAA0CJ,IAA1C,CAAJ,EAAqD;AACnD,WAAO,EAAP;AACD;;AAED,MAAI,CAACzC,CAAC,CAAC4C,QAAF,CAAW/B,YAAY,CAACgC,gBAAxB,EAA0CH,KAAK,CAAC,CAAD,CAA/C,CAAL,EAA0D;AACxD,WAAO,IAAP;AACD;;AAED,MAAIP,OAAO,GAAGO,KAAK,CAACI,KAAN,CAAY,CAAZ,EAAeC,GAAf,CAAmB,UAASC,IAAT,EAAe;AAC9C,QAAIC,UAAU,GAAGD,IAAI,CAACF,KAAL,CAAW,CAAC,CAAZ,MAAmB,IAApC;;AACA,QAAIG,UAAJ,EAAgB;AACdD,MAAAA,IAAI,GAAGA,IAAI,CAACF,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAP;AACD;;AACD,QAAI,CAACE,IAAD,IAASA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAzB,EAA8B;AAC5B,aAAOE,GAAP;AACD;;AACD,QAAIC,KAAK,GAAG,CAACH,IAAb,CAR8C,CAQ3B;;AACnB,QAAIC,UAAJ,EAAgB;AACdE,MAAAA,KAAK,IAAItC,YAAY,CAAC0B,QAAtB;AACD;;AAED,WAAOY,KAAP;AACD,GAda,CAAd;AAgBA,SAAOnD,CAAC,CAACoD,GAAF,CAAMjB,OAAN,EAAekB,KAAf,IAAwB,IAAxB,GAA+BlB,OAAtC;AACD,CA7BD;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAtB,YAAY,CAACyC,SAAb,CAAuBC,MAAvB,GAAgC,UAASpC,GAAT,EAAce,QAAd,EAAwB;AACtD,MAAIlC,CAAC,CAACsC,QAAF,CAAWnB,GAAX,CAAJ,EAAqB;AACnB,WAAO,KAAKqC,iBAAL,CAAuBrC,GAAvB,EAA4Be,QAA5B,CAAP;AACD,GAFD,MAEO,IAAIlC,CAAC,CAACsB,QAAF,CAAWH,GAAX,CAAJ,EAAqB;AAC1B,WAAO,KAAKsC,iBAAL,CAAuBtC,GAAvB,CAAP;AACD,GAFM,MAEA;AACL,UAAM,IAAIP,QAAQ,CAAC8C,yBAAb,CAAuCvC,GAAvC,CAAN;AACD;AACF,CARD;;AAUAN,YAAY,CAACyC,SAAb,CAAuBE,iBAAvB,GAA2C,UAASL,KAAT,EAAgBjB,QAAhB,EAA0B;AACnE;;AACA;AACA,MAAI,CAACrB,YAAY,CAACoB,WAAb,CAAyBkB,KAAzB,EAAgCjB,QAAhC,CAAL,EAAgD;AAC9C,UAAM,IAAItB,QAAQ,CAAC+C,WAAb,CAAyBR,KAAzB,CAAN;AACD;;AAEDjB,EAAAA,QAAQ,GAAGiB,KAAK,IAAItC,YAAY,CAAC0B,QAAtB,GAAiC,IAAjC,GAAwCL,QAAnD;;AACA,MAAIiB,KAAK,GAAGtC,YAAY,CAAC0B,QAArB,IAAiCL,QAAQ,KAAK,IAAlD,EAAwD;AACtDiB,IAAAA,KAAK,IAAItC,YAAY,CAAC0B,QAAtB;AACD;;AAED,MAAIqB,MAAM,GAAGrD,UAAU,CAACc,GAAX,CAAe,KAAKwC,QAApB,EAA8BV,KAA9B,EAAqCjB,QAArC,CAAb;;AACA,MAAI0B,MAAJ,EAAY;AACV,WAAOA,MAAP;AACD;;AAED,MAAIE,WAAW,GAAGhD,UAAU,CAACiD,eAAX,CAA2BZ,KAA3B,CAAlB;AACA,MAAIa,IAAJ;;AACA,MAAI9B,QAAJ,EAAc;AACZ8B,IAAAA,IAAI,GAAGlD,UAAU,CAACmD,MAAX,CAAkB,CAAC,IAAIlE,MAAM,CAACmE,MAAX,CAAkB,CAAC,CAAD,CAAlB,CAAD,EAAyB,KAAKC,UAAL,CAAgBC,QAAhB,EAAzB,EAAqDN,WAArD,CAAlB,CAAP;AACD,GAFD,MAEO;AACLE,IAAAA,IAAI,GAAGlD,UAAU,CAACmD,MAAX,CAAkB,CAAC,KAAKI,SAAL,CAAeD,QAAf,EAAD,EAA4BN,WAA5B,CAAlB,CAAP;AACD;;AACD,MAAIQ,IAAI,GAAGjE,IAAI,CAACkE,UAAL,CAAgBP,IAAhB,EAAsB,KAAKQ,QAAL,CAAcC,SAApC,CAAX;AACA,MAAIC,QAAQ,GAAGxE,EAAE,CAACyE,UAAH,CAAcL,IAAI,CAACxB,KAAL,CAAW,CAAX,EAAc,EAAd,CAAd,EAAiC;AAC9C8B,IAAAA,IAAI,EAAE;AADwC,GAAjC,CAAf;AAGA,MAAIH,SAAS,GAAGH,IAAI,CAACxB,KAAL,CAAW,EAAX,EAAe,EAAf,CAAhB;AAEA,MAAIqB,UAAU,GAAGO,QAAQ,CAACG,GAAT,CAAa,KAAKV,UAAL,CAAgBW,WAAhB,EAAb,EAA4CC,GAA5C,CAAgDvE,KAAK,CAACwE,IAAN,EAAhD,EAA8DZ,QAA9D,CAAuE;AACtFQ,IAAAA,IAAI,EAAE;AADgF,GAAvE,CAAjB;AAIA,MAAIK,OAAO,GAAG,IAAIpE,YAAJ,CAAiB;AAC7BqE,IAAAA,OAAO,EAAE,KAAKA,OADe;AAE7BC,IAAAA,KAAK,EAAE,KAAKA,KAAL,GAAa,CAFS;AAG7BC,IAAAA,iBAAiB,EAAE,KAAKC,WAHK;AAI7BC,IAAAA,UAAU,EAAEnC,KAJiB;AAK7BsB,IAAAA,SAAS,EAAEA,SALkB;AAM7BN,IAAAA,UAAU,EAAEA;AANiB,GAAjB,CAAd;AAQA5D,EAAAA,UAAU,CAACgF,GAAX,CAAe,KAAK1B,QAApB,EAA8BV,KAA9B,EAAqCjB,QAArC,EAA+C+C,OAA/C;AACA,SAAOA,OAAP;AACD,CA5CD;;AA8CApE,YAAY,CAACyC,SAAb,CAAuBG,iBAAvB,GAA2C,UAAShB,IAAT,EAAe;AACxD,MAAI,CAAC5B,YAAY,CAACoB,WAAb,CAAyBQ,IAAzB,CAAL,EAAqC;AACnC,UAAM,IAAI7B,QAAQ,CAAC+C,WAAb,CAAyBlB,IAAzB,CAAN;AACD;;AAED,MAAIN,OAAO,GAAGtB,YAAY,CAACuB,qBAAb,CAAmCK,IAAnC,CAAd;;AACA,MAAIwC,OAAO,GAAG9C,OAAO,CAACqD,MAAR,CAAe,UAASC,IAAT,EAAetC,KAAf,EAAsB;AACjD,WAAOsC,IAAI,CAACjC,iBAAL,CAAuBL,KAAvB,CAAP;AACD,GAFa,EAEX,IAFW,CAAd;AAIA,SAAO8B,OAAP;AACD,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACApE,YAAY,CAACW,iBAAb,GAAiC,UAASwC,IAAT,EAAekB,OAAf,EAAwB;AACvD,SAAO,CAACrE,YAAY,CAACgB,kBAAb,CAAgCmC,IAAhC,EAAsCkB,OAAtC,CAAR;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACArE,YAAY,CAACgB,kBAAb,GAAkC,UAASmC,IAAT,EAAekB,OAAf,EAAwB;AACxD;AACA,MAAI,EAAElF,CAAC,CAACsB,QAAF,CAAW0C,IAAX,KAAoBlD,UAAU,CAACS,QAAX,CAAoByC,IAApB,CAAtB,CAAJ,EAAsD;AACpD,WAAO,IAAIpD,QAAQ,CAACoB,oBAAb,CAAkC,2BAAlC,CAAP;AACD;;AACD,MAAI,CAAC7B,MAAM,CAACuF,eAAP,CAAuB1B,IAAvB,CAAL,EAAmC;AACjC,WAAO,IAAIrD,MAAM,CAACgF,cAAX,CAA0B,WAA1B,EAAuC3B,IAAvC,CAAP;AACD;;AACD,MAAI;AACFA,IAAAA,IAAI,GAAG5D,WAAW,CAACwF,MAAZ,CAAmB5B,IAAnB,CAAP;AACD,GAFD,CAEE,OAAO6B,CAAP,EAAU;AACV,WAAO,IAAIlF,MAAM,CAACmF,kBAAX,CAA8B9B,IAA9B,CAAP;AACD;;AACD,MAAIA,IAAI,CAAC+B,MAAL,KAAgBlF,YAAY,CAACmF,UAAjC,EAA6C;AAC3C,WAAO,IAAIpF,QAAQ,CAACqF,aAAb,CAA2BjC,IAA3B,CAAP;AACD;;AACD,MAAI,CAAChE,CAAC,CAACkG,WAAF,CAAchB,OAAd,CAAL,EAA6B;AAC3B,QAAIiB,KAAK,GAAGtF,YAAY,CAACuF,gBAAb,CAA8BpC,IAA9B,EAAoCkB,OAApC,CAAZ;;AACA,QAAIiB,KAAJ,EAAW;AACT,aAAOA,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD,CAvBD;;AAyBAtF,YAAY,CAACuF,gBAAb,GAAgC,UAASpC,IAAT,EAAeqC,UAAf,EAA2B;AACzD,MAAInB,OAAO,GAAG5E,OAAO,CAACe,GAAR,CAAYgF,UAAZ,CAAd;;AACA,MAAI,CAACnB,OAAL,EAAc;AACZ,WAAO,IAAIvE,MAAM,CAAC2F,sBAAX,CAAkCD,UAAlC,CAAP;AACD;;AACD,MAAIE,OAAO,GAAGvC,IAAI,CAAClB,KAAL,CAAW,CAAX,EAAc,CAAd,CAAd;;AACA,MAAIhC,UAAU,CAAC0F,iBAAX,CAA6BD,OAA7B,MAA0CrB,OAAO,CAACrB,QAAtD,EAAgE;AAC9D,WAAO,IAAIlD,MAAM,CAAC8F,cAAX,CAA0BF,OAA1B,CAAP;AACD;;AACD,SAAO,IAAP;AACD,CAVD;;AAYA1F,YAAY,CAAC6F,UAAb,GAA0B,UAASvF,GAAT,EAAc;AACtClB,EAAAA,CAAC,CAAC0G,aAAF,CAAgB3G,CAAC,CAACsB,QAAF,CAAWH,GAAX,CAAhB,EAAiC,8BAAjC;AACA,SAAO,IAAIN,YAAJ,CAAiBM,GAAjB,CAAP;AACD,CAHD;;AAKAN,YAAY,CAAC+F,UAAb,GAA0B,UAASzF,GAAT,EAAc;AACtClB,EAAAA,CAAC,CAAC0G,aAAF,CAAgB3G,CAAC,CAAC8B,QAAF,CAAWX,GAAX,CAAhB,EAAiC,gCAAjC;AACA,SAAO,IAAIN,YAAJ,CAAiBM,GAAjB,CAAP;AACD,CAHD;;AAKAN,YAAY,CAACyC,SAAb,CAAuB3B,cAAvB,GAAwC,UAASR,GAAT,EAAc;AACpD,SAAO,KAAKY,gBAAL,CAAsB8E,IAAI,CAACC,KAAL,CAAW3F,GAAX,CAAtB,CAAP;AACD,CAFD;;AAIAN,YAAY,CAACyC,SAAb,CAAuBvB,gBAAvB,GAA0C,UAASZ,GAAT,EAAc;AACtD;AACA;AACA,MAAI4F,OAAO,GAAG;AACZR,IAAAA,OAAO,EAAEpF,GAAG,CAAC+D,OAAJ,GAAcpE,UAAU,CAACiD,eAAX,CAA2BzD,OAAO,CAACe,GAAR,CAAYF,GAAG,CAAC+D,OAAhB,EAAyBrB,QAApD,CAAd,GAA8E1C,GAAG,CAACoF,OAD/E;AAEZpB,IAAAA,KAAK,EAAEnF,CAAC,CAACsC,QAAF,CAAWnB,GAAG,CAACgE,KAAf,IAAwBrE,UAAU,CAACkG,yBAAX,CAAqC7F,GAAG,CAACgE,KAAzC,CAAxB,GAA0EhE,GAAG,CAACgE,KAFzE;AAGZC,IAAAA,iBAAiB,EAAEpF,CAAC,CAACsC,QAAF,CAAWnB,GAAG,CAACiE,iBAAf,IAAoCtE,UAAU,CAACiD,eAAX,CAA2B5C,GAAG,CAACiE,iBAA/B,CAApC,GAAwFjE,GAAG,CAACiE,iBAHnG;AAIZE,IAAAA,UAAU,EAAEtF,CAAC,CAACsC,QAAF,CAAWnB,GAAG,CAACmE,UAAf,IAA6BxE,UAAU,CAACiD,eAAX,CAA2B5C,GAAG,CAACmE,UAA/B,CAA7B,GAA0EnE,GAAG,CAACmE,UAJ9E;AAKZb,IAAAA,SAAS,EAAEzE,CAAC,CAACsB,QAAF,CAAWH,GAAG,CAACsD,SAAf,IAA4B3D,UAAU,CAACmG,WAAX,CAAuB9F,GAAG,CAACsD,SAA3B,CAA5B,GAAoEtD,GAAG,CAACsD,SALvE;AAMZN,IAAAA,UAAU,EAAGnE,CAAC,CAACsB,QAAF,CAAWH,GAAG,CAACgD,UAAf,KAA8BpD,MAAM,CAACmG,MAAP,CAAc/F,GAAG,CAACgD,UAAlB,CAA/B,GAAgErD,UAAU,CAACmG,WAAX,CAAuB9F,GAAG,CAACgD,UAA3B,CAAhE,GAAyGhD,GAAG,CAACgD,UAN7G;AAOZgD,IAAAA,QAAQ,EAAEhG,GAAG,CAACgG,QAAJ,GAAgBhG,GAAG,CAACgG,QAAJ,CAAapB,MAAb,GAAsB5E,GAAG,CAACgG,QAA1B,GAAqCrG,UAAU,CAACiD,eAAX,CAA2B5C,GAAG,CAACgG,QAA/B,CAArD,GAAiGC;AAP/F,GAAd;AASA,SAAO,KAAKC,iBAAL,CAAuBN,OAAvB,CAAP;AACD,CAbD;;AAeAlG,YAAY,CAACyC,SAAb,CAAuB7B,oBAAvB,GAA8C,UAASN,GAAT,EAAc;AAC1D,MAAImG,OAAO,GAAGlH,WAAW,CAACwF,MAAZ,CAAmBzE,GAAnB,CAAd;AACA,MAAI4F,OAAO,GAAG;AACZR,IAAAA,OAAO,EAAEe,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAAC0G,YAA3B,EAAyC1G,YAAY,CAAC2G,UAAtD,CADG;AAEZrC,IAAAA,KAAK,EAAEmC,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAAC4G,UAA3B,EAAuC5G,YAAY,CAAC6G,QAApD,CAFK;AAGZtC,IAAAA,iBAAiB,EAAEkC,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAAC8G,sBAA3B,EACjB9G,YAAY,CAAC+G,oBADI,CAHP;AAKZtC,IAAAA,UAAU,EAAEgC,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAACgH,eAA3B,EAA4ChH,YAAY,CAACiH,aAAzD,CALA;AAMZrD,IAAAA,SAAS,EAAE6C,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAACkH,cAA3B,EAA2ClH,YAAY,CAACmH,YAAxD,CANC;AAOZ7D,IAAAA,UAAU,EAAEmD,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAACoH,eAA3B,EAA4CpH,YAAY,CAACqH,aAAzD,CAPA;AAQZf,IAAAA,QAAQ,EAAEG,OAAO,CAACxE,KAAR,CAAcjC,YAAY,CAACsH,aAA3B,EAA0CtH,YAAY,CAACuH,WAAvD,CARE;AASZvE,IAAAA,QAAQ,EAAE1C;AATE,GAAd;AAWA,SAAO,KAAKkG,iBAAL,CAAuBN,OAAvB,CAAP;AACD,CAdD;;AAgBAlG,YAAY,CAACyC,SAAb,CAAuBlC,iBAAvB,GAA2C,UAAS8D,OAAT,EAAkB;AAC3D,SAAOrE,YAAY,CAACwH,QAAb,CAAsB3H,MAAM,CAAC4H,eAAP,CAAuB,EAAvB,CAAtB,EAAkDpD,OAAlD,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACArE,YAAY,CAACwH,QAAb,GAAwB,UAASE,IAAT,EAAerD,OAAf,EAAwB;AAC9C;AACA,MAAInE,MAAM,CAACyH,YAAP,CAAoBD,IAApB,CAAJ,EAA+B;AAC7BA,IAAAA,IAAI,GAAGzH,UAAU,CAACmG,WAAX,CAAuBsB,IAAvB,CAAP;AACD;;AACD,MAAI,CAACrE,MAAM,CAAC3C,QAAP,CAAgBgH,IAAhB,CAAL,EAA4B;AAC1B,UAAM,IAAI3H,QAAQ,CAAC6H,sBAAb,CAAoCF,IAApC,CAAN;AACD;;AACD,MAAIA,IAAI,CAACxC,MAAL,GAAc/E,oBAAoB,GAAGC,aAAzC,EAAwD;AACtD,UAAM,IAAIL,QAAQ,CAAC6H,sBAAT,CAAgCC,gBAApC,CAAqDH,IAArD,CAAN;AACD;;AACD,MAAIA,IAAI,CAACxC,MAAL,GAAc7E,oBAAoB,GAAGD,aAAzC,EAAwD;AACtD,UAAM,IAAIL,QAAQ,CAAC6H,sBAAT,CAAgCE,cAApC,CAAmDJ,IAAnD,CAAN;AACD;;AACD,MAAIjE,IAAI,GAAGjE,IAAI,CAACkE,UAAL,CAAgBgE,IAAhB,EAAsB,IAAIxI,MAAM,CAACmE,MAAX,CAAkB,cAAlB,CAAtB,CAAX;AAEA,SAAO,IAAIrD,YAAJ,CAAiB;AACtBqE,IAAAA,OAAO,EAAE5E,OAAO,CAACe,GAAR,CAAY6D,OAAZ,KAAwB5E,OAAO,CAACsI,cADnB;AAEtBzD,IAAAA,KAAK,EAAE,CAFe;AAGtBC,IAAAA,iBAAiB,EAAE,CAHG;AAItBE,IAAAA,UAAU,EAAE,CAJU;AAKtBnB,IAAAA,UAAU,EAAEG,IAAI,CAACxB,KAAL,CAAW,CAAX,EAAc,EAAd,CALU;AAMtB2B,IAAAA,SAAS,EAAEH,IAAI,CAACxB,KAAL,CAAW,EAAX,EAAe,EAAf;AANW,GAAjB,CAAP;AAQD,CAxBD;;AA4BAjC,YAAY,CAACyC,SAAb,CAAuBuF,gBAAvB,GAA0C,YAAW;AACnD,MAAI,CAAC,KAAKC,YAAV,EAAwB;AACtB,QAAIC,WAAW,GAAGjJ,OAAO,CAAC,eAAD,CAAzB;;AACA,SAAKgJ,YAAL,GAAoB,IAAIC,WAAJ,CAAgB,IAAhB,CAApB;AACD;AACF,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlI,YAAY,CAACyC,SAAb,CAAuB+D,iBAAvB,GAA2C,UAASlG,GAAT,EAAc;AACvD;;AACA;AAEAN,EAAAA,YAAY,CAACmI,wBAAb,CAAsC7H,GAAtC;;AAEAJ,EAAAA,MAAM,CAACkI,eAAP,CAAuB,IAAvB,EAA6B;AAC3BzE,IAAAA,QAAQ,EAAErD;AADiB,GAA7B;AAIA,MAAI+H,QAAQ,GAAG,CACb/H,GAAG,CAACoF,OADS,EACApF,GAAG,CAACgE,KADJ,EACWhE,GAAG,CAACiE,iBADf,EACkCjE,GAAG,CAACmE,UADtC,EACkDnE,GAAG,CAACsD,SADtD,EAEb3D,UAAU,CAACqI,WAAX,CAAuB,CAAvB,CAFa,EAEchI,GAAG,CAACgD,UAFlB,CAAf;AAIA,MAAIF,MAAM,GAAGlE,MAAM,CAACmE,MAAP,CAAcD,MAAd,CAAqBiF,QAArB,CAAb;;AACA,MAAI,CAAC/H,GAAG,CAACgG,QAAL,IAAiB,CAAChG,GAAG,CAACgG,QAAJ,CAAapB,MAAnC,EAA2C;AACzC5E,IAAAA,GAAG,CAACgG,QAAJ,GAAe/G,WAAW,CAAC+G,QAAZ,CAAqBlD,MAArB,CAAf;AACD,GAFD,MAEO;AACL,QAAI9C,GAAG,CAACgG,QAAJ,CAAavF,QAAb,OAA4BxB,WAAW,CAAC+G,QAAZ,CAAqBlD,MAArB,EAA6BrC,QAA7B,EAAhC,EAAyE;AACvE,YAAM,IAAIjB,MAAM,CAACmF,kBAAX,CAA8B7B,MAA9B,CAAN;AACD;AACF;;AAED,MAAIiB,OAAO,GAAG5E,OAAO,CAACe,GAAR,CAAYP,UAAU,CAAC0F,iBAAX,CAA6BrF,GAAG,CAACoF,OAAjC,CAAZ,CAAd;AACA,MAAI1C,QAAJ;AACAA,EAAAA,QAAQ,GAAGzD,WAAW,CAACgJ,MAAZ,CAAmBrJ,MAAM,CAACmE,MAAP,CAAcD,MAAd,CAAqBiF,QAArB,CAAnB,CAAX;AACA/H,EAAAA,GAAG,CAAC0C,QAAJ,GAAe,IAAIK,MAAJ,CAAWL,QAAX,CAAf;AAEA,MAAIM,UAAU,GAAG,IAAI1D,UAAJ,CAAeP,EAAE,CAACyE,UAAH,CAAcxD,GAAG,CAACgD,UAAlB,CAAf,EAA8Ce,OAA9C,CAAjB;AACA,MAAIb,SAAS,GAAGF,UAAU,CAACkF,WAAX,EAAhB;AACA,MAAIzE,IAAI,GAAG/D,YAAY,CAACyI,qBAAxB;AACA,MAAIjE,WAAW,GAAGhF,IAAI,CAACkJ,eAAL,CAAqBlF,SAAS,CAACD,QAAV,EAArB,EAA2CtB,KAA3C,CAAiD,CAAjD,EAAoD8B,IAApD,CAAlB;AAEA7D,EAAAA,MAAM,CAACkI,eAAP,CAAuB,IAAvB,EAA6B;AAC3BpF,IAAAA,QAAQ,EAAEA,QADiB;AAE3BqB,IAAAA,OAAO,EAAEA,OAFkB;AAG3BC,IAAAA,KAAK,EAAErE,UAAU,CAAC0I,2BAAX,CAAuCrI,GAAG,CAACgE,KAA3C,CAHoB;AAI3BhB,IAAAA,UAAU,EAAEA,UAJe;AAK3BE,IAAAA,SAAS,EAAEA,SALgB;AAM3BgB,IAAAA,WAAW,EAAEA;AANc,GAA7B;AASA,OAAKyD,YAAL,GAAoB,IAApB;AAEAW,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,aAA5B,EAA2C;AACzCC,IAAAA,YAAY,EAAE,KAD2B;AAEzCC,IAAAA,UAAU,EAAE,IAF6B;AAGzCvI,IAAAA,GAAG,EAAE,YAAW;AACd,WAAKwH,gBAAL;;AACA,aAAO,KAAKC,YAAZ;AACD;AANwC,GAA3C;AAQAW,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACrCC,IAAAA,YAAY,EAAE,KADuB;AAErCC,IAAAA,UAAU,EAAE,IAFyB;AAGrCvI,IAAAA,GAAG,EAAE,YAAW;AACd,WAAKwH,gBAAL;;AACA,aAAO,KAAKC,YAAL,CAAkBe,OAAzB;AACD;AANoC,GAAvC;AAQA,SAAO,IAAP;AACD,CA7DD;;AA+DAhJ,YAAY,CAACmI,wBAAb,GAAwC,UAAS7H,GAAT,EAAc;AACpD,MAAI2I,WAAW,GAAG,UAASC,IAAT,EAAenF,IAAf,EAAqB;AACrC,QAAIoF,IAAI,GAAG7I,GAAG,CAAC4I,IAAD,CAAd;AACAlK,IAAAA,MAAM,CAACiB,UAAU,CAACS,QAAX,CAAoByI,IAApB,CAAD,EAA4BD,IAAI,GAAG,2BAAnC,CAAN;AACAlK,IAAAA,MAAM,CACJmK,IAAI,CAACjE,MAAL,KAAgBnB,IADZ,EAEJmF,IAAI,GAAG,oCAAP,GAA8CC,IAAI,CAACjE,MAAnD,GAA4D,aAA5D,GAA4EnB,IAFxE,CAAN;AAID,GAPD;;AAQAkF,EAAAA,WAAW,CAAC,SAAD,EAAYjJ,YAAY,CAACoJ,WAAzB,CAAX;AACAH,EAAAA,WAAW,CAAC,OAAD,EAAUjJ,YAAY,CAACqJ,SAAvB,CAAX;AACAJ,EAAAA,WAAW,CAAC,mBAAD,EAAsBjJ,YAAY,CAACyI,qBAAnC,CAAX;AACAQ,EAAAA,WAAW,CAAC,YAAD,EAAejJ,YAAY,CAACsJ,cAA5B,CAAX;AACAL,EAAAA,WAAW,CAAC,WAAD,EAAcjJ,YAAY,CAACuJ,aAA3B,CAAX;AACAN,EAAAA,WAAW,CAAC,YAAD,EAAejJ,YAAY,CAACwJ,cAA5B,CAAX;;AACA,MAAIlJ,GAAG,CAACgG,QAAJ,IAAgBhG,GAAG,CAACgG,QAAJ,CAAapB,MAAjC,EAAyC;AACvC+D,IAAAA,WAAW,CAAC,UAAD,EAAajJ,YAAY,CAACyJ,YAA1B,CAAX;AACD;AACF,CAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;;;AACAzJ,YAAY,CAACyC,SAAb,CAAuB1B,QAAvB,GAAkC,YAAW;AAC3C,SAAO,KAAKiC,QAAZ;AACD,CAFD;AAIA;AACA;AACA;AACA;;;AACAhD,YAAY,CAACyC,SAAb,CAAuBiH,OAAvB,GAAiC,YAAW;AAC1C,SAAO,oBAAoB,KAAK1G,QAAzB,GAAoC,GAA3C;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhD,YAAY,CAACyC,SAAb,CAAuBkH,QAAvB,GAAkC3J,YAAY,CAACyC,SAAb,CAAuBmH,MAAvB,GAAgC,SAASD,QAAT,GAAoB;AACpF,SAAO;AACLtF,IAAAA,OAAO,EAAE5E,OAAO,CAACe,GAAR,CAAYP,UAAU,CAAC0F,iBAAX,CAA6B,KAAKhC,QAAL,CAAc+B,OAA3C,CAAZ,EAAiE,UAAjE,EAA6EwD,IADjF;AAEL5E,IAAAA,KAAK,EAAErE,UAAU,CAAC0I,2BAAX,CAAuC,KAAKhF,QAAL,CAAcW,KAArD,CAFF;AAGLE,IAAAA,WAAW,EAAEvE,UAAU,CAAC0F,iBAAX,CAA6B,KAAKnB,WAAlC,CAHR;AAILD,IAAAA,iBAAiB,EAAEtE,UAAU,CAAC0F,iBAAX,CAA6B,KAAKhC,QAAL,CAAcY,iBAA3C,CAJd;AAKLE,IAAAA,UAAU,EAAExE,UAAU,CAAC0F,iBAAX,CAA6B,KAAKhC,QAAL,CAAcc,UAA3C,CALP;AAMLb,IAAAA,SAAS,EAAE3D,UAAU,CAAC4J,WAAX,CAAuB,KAAKlG,QAAL,CAAcC,SAArC,CANN;AAOLN,IAAAA,UAAU,EAAE,KAAKA,UAAL,CAAgBC,QAAhB,GAA2BxC,QAA3B,CAAoC,KAApC,CAPP;AAQLuF,IAAAA,QAAQ,EAAErG,UAAU,CAAC0F,iBAAX,CAA6B,KAAKhC,QAAL,CAAc2C,QAA3C,CARL;AASLtD,IAAAA,QAAQ,EAAE,KAAKA;AATV,GAAP;AAWD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;;;AACAhD,YAAY,CAAC8D,UAAb,GAA0B,UAASxD,GAAT,EAAc;AACtC,SAAO,IAAIN,YAAJ,CAAiBM,GAAG,CAACS,QAAJ,EAAjB,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACAf,YAAY,CAACyC,SAAb,CAAuBc,QAAvB,GAAkC,YAAW;AAC3C,SAAOtD,UAAU,CAAC6J,IAAX,CAAgB,KAAKnG,QAAL,CAAcX,QAA9B,CAAP;AACD,CAFD;;AAIAhD,YAAY,CAAC+J,YAAb,GAA4B,CAA5B;AACA/J,YAAY,CAACgK,kBAAb,GAAkC,CAAlC;AACAhK,YAAY,CAACiK,iBAAb,GAAiC,CAAjC;AACAjK,YAAY,CAAC0B,QAAb,GAAwB,UAAxB;AACA1B,YAAY,CAAC2B,QAAb,GAAwB,IAAI3B,YAAY,CAAC0B,QAAzC;AAEA1B,YAAY,CAACgC,gBAAb,GAAgC,CAAC,GAAD,EAAM,GAAN,EAAW,KAAX,EAAkB,KAAlB,CAAhC;AAEAhC,YAAY,CAACoJ,WAAb,GAA2B,CAA3B;AACApJ,YAAY,CAACqJ,SAAb,GAAyB,CAAzB;AACArJ,YAAY,CAACyI,qBAAb,GAAqC,CAArC;AACAzI,YAAY,CAACsJ,cAAb,GAA8B,CAA9B;AACAtJ,YAAY,CAACuJ,aAAb,GAA6B,EAA7B;AACAvJ,YAAY,CAACwJ,cAAb,GAA8B,EAA9B;AACAxJ,YAAY,CAACyJ,YAAb,GAA4B,CAA5B;AAEAzJ,YAAY,CAACmF,UAAb,GAA0B,EAA1B;AACAnF,YAAY,CAACkK,kBAAb,GAAkC,EAAlC;AAEAlK,YAAY,CAAC0G,YAAb,GAA4B,CAA5B;AACA1G,YAAY,CAAC2G,UAAb,GAA0B3G,YAAY,CAAC0G,YAAb,GAA4B1G,YAAY,CAACoJ,WAAnE;AACApJ,YAAY,CAAC4G,UAAb,GAA0B5G,YAAY,CAAC2G,UAAvC;AACA3G,YAAY,CAAC6G,QAAb,GAAwB7G,YAAY,CAAC4G,UAAb,GAA0B5G,YAAY,CAACqJ,SAA/D;AACArJ,YAAY,CAAC8G,sBAAb,GAAsC9G,YAAY,CAAC6G,QAAnD;AACA7G,YAAY,CAAC+G,oBAAb,GAAoC/G,YAAY,CAAC8G,sBAAb,GAAsC9G,YAAY,CAACyI,qBAAvF;AACAzI,YAAY,CAACgH,eAAb,GAA+BhH,YAAY,CAAC+G,oBAA5C;AACA/G,YAAY,CAACiH,aAAb,GAA6BjH,YAAY,CAACgH,eAAb,GAA+BhH,YAAY,CAACsJ,cAAzE;AACAtJ,YAAY,CAACkH,cAAb,GAA8BlH,YAAY,CAACiH,aAA3C;AACAjH,YAAY,CAACmH,YAAb,GAA4BnH,YAAY,CAACkH,cAAb,GAA8BlH,YAAY,CAACuJ,aAAvE;AACAvJ,YAAY,CAACoH,eAAb,GAA+BpH,YAAY,CAACmH,YAAb,GAA4B,CAA3D;AACAnH,YAAY,CAACqH,aAAb,GAA6BrH,YAAY,CAACoH,eAAb,GAA+BpH,YAAY,CAACwJ,cAAzE;AACAxJ,YAAY,CAACsH,aAAb,GAA6BtH,YAAY,CAACqH,aAA1C;AACArH,YAAY,CAACuH,WAAb,GAA2BvH,YAAY,CAACsH,aAAb,GAA6BtH,YAAY,CAACyJ,YAArE;AAEAzK,MAAM,CAACgB,YAAY,CAACuH,WAAb,KAA6BvH,YAAY,CAACkK,kBAA3C,CAAN;AAEAC,MAAM,CAACC,OAAP,GAAiBpK,YAAjB","sourcesContent":["'use strict';\n\n\nvar assert = require('assert');\nvar buffer = require('buffer');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar Network = require('./networks');\nvar HDKeyCache = require('./hdkeycache');\nvar Point = require('./crypto/point');\nvar PrivateKey = require('./privatekey');\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.all(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.contains(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.contains(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.any(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var cached = HDKeyCache.get(this.xprivkey, index, hardened);\n  if (cached) {\n    return cached;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened) {\n    data = BufferUtil.concat([new buffer.Buffer([0]), this.privateKey.toBuffer(), indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).mod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n  HDKeyCache.set(this.xprivkey, index, hardened, derived);\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = BufferUtil.hexToBuffer(hexa);\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, new buffer.Buffer('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\n\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = new Buffer(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n"]},"metadata":{},"sourceType":"script"}