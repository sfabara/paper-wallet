{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\n\nvar Base58 = require('./encoding/base58');\n\nvar Base58Check = require('./encoding/base58check');\n\nvar Hash = require('./crypto/hash');\n\nvar HDPrivateKey = require('./hdprivatekey');\n\nvar HDKeyCache = require('./hdkeycache');\n\nvar Network = require('./networks');\n\nvar Point = require('./crypto/point');\n\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\n\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\n\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\n\nvar BufferUtil = require('./util/buffer');\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\n\n\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidPath = function (arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n\n    return indexes !== null && _.all(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n/**\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\n\n\nHDPublicKey.prototype.derive = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function (index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  var cached = HDKeyCache.get(this.xpubkey, index, false);\n\n  if (cached) {\n    return cached;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  HDKeyCache.set(this.xpubkey, index, false, derived);\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function (path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.contains(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n  return derived;\n};\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\n\n\nHDPublicKey.isValidSerialized = function (data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\n\n\nHDPublicKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n\n    if (error) {\n      return error;\n    }\n  }\n\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n\n  return null;\n};\n\nHDPublicKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? BufferUtil.hexToBuffer(arg.publicKey) : BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart, HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\n\n\nHDPublicKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n\n  /* jshint maxstatements: 20 */\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, arg.publicKey];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = new Buffer(xpubkey);\n  var publicKey = new PublicKey(arg.publicKey, {\n    network: network\n  });\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function checkBuffer(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\n\n\nHDPublicKey.prototype.toString = function () {\n  return this.xpubkey;\n};\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\n\n\nHDPublicKey.prototype.inspect = function () {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\n\n\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\n\n\nHDPublicKey.fromBuffer = function (arg) {\n  return new HDPublicKey(arg);\n};\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\n\n\nHDPublicKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\nHDPublicKey.VersionStart = 0;\nHDPublicKey.VersionEnd = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\nmodule.exports = HDPublicKey;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/hdpublickey.js"],"names":["_","require","$","BN","Base58","Base58Check","Hash","HDPrivateKey","HDKeyCache","Network","Point","PublicKey","bitcoreErrors","errors","hdErrors","HDPublicKey","assert","JSUtil","BufferUtil","arg","isString","isBuffer","error","getSerializedError","_buildFromSerialized","toString","ArgumentIsPrivateExtended","hdPublicKey","isObject","_buildFromPrivate","_buildFromObject","UnrecognizedArgument","MustSupplyArgument","isValidPath","indexes","_getDerivationIndexes","all","isNumber","Hardened","prototype","derive","hardened","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","index","InvalidIndexCantDeriveHardened","InvalidPath","cached","get","xpubkey","indexBuffer","integerAsBuffer","data","concat","publicKey","toBuffer","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","slice","size","fromPoint","getG","mul","add","point","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","set","path","contains","reduce","prev","isValidSerialized","isNull","validCharacters","InvalidB58Char","decode","e","InvalidB58Checksum","length","DataSize","InvalidLength","isUndefined","_validateNetwork","version","integerFromBuffer","livenet","xprivkey","testnet","networkArg","InvalidNetworkArgument","VersionStart","VersionEnd","InvalidNetwork","args","clone","privateKey","pointToCompressed","undefined","checksum","_buildFromBuffers","buffers","integerAsSingleByteBuffer","hexToBuffer","decoded","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PublicKeyStart","PublicKeyEnd","ChecksumStart","ChecksumEnd","_validateBufferArguments","defineImmutable","sequence","encode","Buffer","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PublicKeySize","CheckSumSize","fromString","checkArgument","fromObject","inspect","toObject","toJSON","bufferToHex","copy","RootElementAlias","SerializedByteSize","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar HDPrivateKey = require('./hdprivatekey');\nvar HDKeyCache = require('./hdkeycache');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PublicKey = require('./publickey');\n\nvar bitcoreErrors = require('./errors');\nvar errors = bitcoreErrors;\nvar hdErrors = bitcoreErrors.HDPublicKey;\nvar assert = require('assert');\n\nvar JSUtil = require('./util/js');\nvar BufferUtil = require('./util/buffer');\n\n/**\n * The representation of an hierarchically derived public key.\n *\n * See https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {Object|string|Buffer} arg\n */\nfunction HDPublicKey(arg) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n  if (arg instanceof HDPublicKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPublicKey)) {\n    return new HDPublicKey(arg);\n  }\n  if (arg) {\n    if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n      var error = HDPublicKey.getSerializedError(arg);\n      if (!error) {\n        return this._buildFromSerialized(arg);\n      } else if (BufferUtil.isBuffer(arg) && !HDPublicKey.getSerializedError(arg.toString())) {\n        return this._buildFromSerialized(arg.toString());\n      } else {\n        if (error instanceof hdErrors.ArgumentIsPrivateExtended) {\n          return new HDPrivateKey(arg).hdPublicKey;\n        }\n        throw error;\n      }\n    } else {\n      if (_.isObject(arg)) {\n        if (arg instanceof HDPrivateKey) {\n          return this._buildFromPrivate(arg);\n        } else {\n          return this._buildFromObject(arg);\n        }\n      } else {\n        throw new hdErrors.UnrecognizedArgument(arg);\n      }\n    }\n  } else {\n    throw new hdErrors.MustSupplyArgument();\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @return {boolean}\n */\nHDPublicKey.isValidPath = function(arg) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.all(indexes, HDPublicKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    return arg >= 0 && arg < HDPublicKey.Hardened;\n  }\n\n  return false;\n};\n\n/**\n * Get a derivated child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same public key), \"m/0/1/40/2/1000\".\n *\n * Note that hardened keys can't be derived from a public extended key.\n *\n * If the first argument is a number, the child with that index will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPublicKey('xpub...');\n * var child_0_1_2 = parent.derive(0).derive(1).derive(2);\n * var copy_of_child_0_1_2 = parent.derive(\"m/0/1/2\");\n * assert(child_0_1_2.xprivkey === copy_of_child_0_1_2);\n * ```\n *\n * @param {string|number} arg\n */\nHDPublicKey.prototype.derive = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPublicKey.prototype._deriveWithNumber = function(index, hardened) {\n  if (index >= HDPublicKey.Hardened || hardened) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  }\n  if (index < 0) {\n    throw new hdErrors.InvalidPath(index);\n  }\n  var cached = HDKeyCache.get(this.xpubkey, index, false);\n  if (cached) {\n    return cached;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {size: 32});\n  var chainCode = hash.slice(32, 64);\n\n  var publicKey = PublicKey.fromPoint(Point.getG().mul(leftPart).add(this.publicKey.point));\n\n  var derived = new HDPublicKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    publicKey: publicKey\n  });\n  HDKeyCache.set(this.xpubkey, index, false, derived);\n  return derived;\n};\n\nHDPublicKey.prototype._deriveFromString = function(path) {\n  /* jshint maxcomplexity: 8 */\n  if (_.contains(path, \"'\")) {\n    throw new hdErrors.InvalidIndexCantDeriveHardened();\n  } else if (!HDPublicKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized public key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPublicKey.isValidSerialized = function(data, network) {\n  return _.isNull(HDPublicKey.getSerializedError(data, network));\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized public key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized public key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors|null}\n */\nHDPublicKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  /* jshint maxstatements: 20 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('expected buffer or string');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPublicKey.DataSize) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPublicKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  var version = BufferUtil.integerFromBuffer(data.slice(0, 4));\n  if (version === Network.livenet.xprivkey || version === Network.testnet.xprivkey ) {\n    return new hdErrors.ArgumentIsPrivateExtended();\n  }\n  return null;\n};\n\nHDPublicKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd);\n  if (BufferUtil.integerFromBuffer(version) !== network.xpubkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPublicKey.prototype._buildFromPrivate = function (arg) {\n  var args = _.clone(arg._buffers);\n  var point = Point.getG().mul(BN.fromBuffer(args.privateKey));\n  args.publicKey = Point.pointToCompressed(point);\n  args.version = BufferUtil.integerAsBuffer(Network.get(BufferUtil.integerFromBuffer(args.version)).xpubkey);\n  args.privateKey = undefined;\n  args.checksum = undefined;\n  args.xprivkey = undefined;\n  return this._buildFromBuffers(args);\n};\n\nHDPublicKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 10 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xpubkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    publicKey: _.isString(arg.publicKey) ? BufferUtil.hexToBuffer(arg.publicKey) :\n      BufferUtil.isBuffer(arg.publicKey) ? arg.publicKey : arg.publicKey.toBuffer(),\n    checksum: _.isNumber(arg.checksum) ? BufferUtil.integerAsBuffer(arg.checksum) : arg.checksum\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPublicKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPublicKey.VersionStart, HDPublicKey.VersionEnd),\n    depth: decoded.slice(HDPublicKey.DepthStart, HDPublicKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPublicKey.ParentFingerPrintStart,\n                                     HDPublicKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPublicKey.ChildIndexStart, HDPublicKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPublicKey.ChainCodeStart, HDPublicKey.ChainCodeEnd),\n    publicKey: decoded.slice(HDPublicKey.PublicKeyStart, HDPublicKey.PublicKeyEnd),\n    checksum: decoded.slice(HDPublicKey.ChecksumStart, HDPublicKey.ChecksumEnd),\n    xpubkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.publicKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xpubkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPublicKey} this\n */\nHDPublicKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPublicKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    arg.publicKey\n  ];\n  var concat = BufferUtil.concat(sequence);\n  var checksum = Base58Check.checksum(concat);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = checksum;\n  } else {\n    if (arg.checksum.toString('hex') !== checksum.toString('hex')) {\n      throw new errors.InvalidB58Checksum(concat, checksum);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n\n  var xpubkey;\n  xpubkey = Base58Check.encode(BufferUtil.concat(sequence));\n  arg.xpubkey = new Buffer(xpubkey);\n\n  var publicKey = new PublicKey(arg.publicKey, {network: network});\n  var size = HDPublicKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xpubkey: xpubkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  return this;\n};\n\nHDPublicKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer, it\\'s ' + typeof buff);\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPublicKey.VersionSize);\n  checkBuffer('depth', HDPublicKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPublicKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPublicKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPublicKey.ChainCodeSize);\n  checkBuffer('publicKey', HDPublicKey.PublicKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPublicKey.CheckSumSize);\n  }\n};\n\nHDPublicKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPublicKey(arg);\n};\n\nHDPublicKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPublicKey(arg);\n};\n\n/**\n * Returns the base58 checked representation of the public key\n * @return {string} a string starting with \"xpub...\" in livenet\n */\nHDPublicKey.prototype.toString = function() {\n  return this.xpubkey;\n};\n\n/**\n * Returns the console representation of this extended public key.\n * @return string\n */\nHDPublicKey.prototype.inspect = function() {\n  return '<HDPublicKey: ' + this.xpubkey + '>';\n};\n\n/**\n * Returns a plain JavaScript object with information to reconstruct a key.\n *\n * Fields are: <ul>\n *  <li> network: 'livenet' or 'testnet'\n *  <li> depth: a number from 0 to 255, the depth to the master extended key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of the public key\n *  <li> fingerPrint: a number of 32 bits taken from the hash of this key's\n *  <li>     parent's public key\n *  <li> childIndex: index with which this key was derived\n *  <li> chainCode: string in hexa encoding used for derivation\n *  <li> publicKey: string, hexa encoded, in compressed key format\n *  <li> checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n *  <li> xpubkey: the string with the base58 representation of this extended key\n *  <li> checksum: the base58 checksum of xpubkey\n * </ul>\n */\nHDPublicKey.prototype.toObject = HDPublicKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version)).name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    publicKey: this.publicKey.toString(),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xpubkey: this.xpubkey\n  };\n};\n\n/**\n * Create a HDPublicKey from a buffer argument\n *\n * @param {Buffer} arg\n * @return {HDPublicKey}\n */\nHDPublicKey.fromBuffer = function(arg) {\n  return new HDPublicKey(arg);\n};\n\n/**\n * Return a buffer representation of the xpubkey\n *\n * @return {Buffer}\n */\nHDPublicKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xpubkey);\n};\n\nHDPublicKey.Hardened = 0x80000000;\nHDPublicKey.RootElementAlias = ['m', 'M'];\n\nHDPublicKey.VersionSize = 4;\nHDPublicKey.DepthSize = 1;\nHDPublicKey.ParentFingerPrintSize = 4;\nHDPublicKey.ChildIndexSize = 4;\nHDPublicKey.ChainCodeSize = 32;\nHDPublicKey.PublicKeySize = 33;\nHDPublicKey.CheckSumSize = 4;\n\nHDPublicKey.DataSize = 78;\nHDPublicKey.SerializedByteSize = 82;\n\nHDPublicKey.VersionStart           = 0;\nHDPublicKey.VersionEnd             = HDPublicKey.VersionStart + HDPublicKey.VersionSize;\nHDPublicKey.DepthStart             = HDPublicKey.VersionEnd;\nHDPublicKey.DepthEnd               = HDPublicKey.DepthStart + HDPublicKey.DepthSize;\nHDPublicKey.ParentFingerPrintStart = HDPublicKey.DepthEnd;\nHDPublicKey.ParentFingerPrintEnd   = HDPublicKey.ParentFingerPrintStart + HDPublicKey.ParentFingerPrintSize;\nHDPublicKey.ChildIndexStart        = HDPublicKey.ParentFingerPrintEnd;\nHDPublicKey.ChildIndexEnd          = HDPublicKey.ChildIndexStart + HDPublicKey.ChildIndexSize;\nHDPublicKey.ChainCodeStart         = HDPublicKey.ChildIndexEnd;\nHDPublicKey.ChainCodeEnd           = HDPublicKey.ChainCodeStart + HDPublicKey.ChainCodeSize;\nHDPublicKey.PublicKeyStart         = HDPublicKey.ChainCodeEnd;\nHDPublicKey.PublicKeyEnd           = HDPublicKey.PublicKeyStart + HDPublicKey.PublicKeySize;\nHDPublicKey.ChecksumStart          = HDPublicKey.PublicKeyEnd;\nHDPublicKey.ChecksumEnd            = HDPublicKey.ChecksumStart + HDPublicKey.CheckSumSize;\n\nassert(HDPublicKey.PublicKeyEnd === HDPublicKey.DataSize);\nassert(HDPublicKey.ChecksumEnd === HDPublicKey.SerializedByteSize);\n\nmodule.exports = HDPublicKey;\n"]},"metadata":{},"sourceType":"script"}