{"ast":null,"code":"'use strict';\n\nvar BN = require('./crypto/bn');\n\nvar Point = require('./crypto/point');\n\nvar Hash = require('./crypto/hash');\n\nvar JSUtil = require('./util/js');\n\nvar Network = require('./networks');\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\n\n\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra); // validation\n\n\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n  return this;\n}\n\n;\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\n\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  }; // detect type of data\n\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(new Buffer(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n\n  return info;\n};\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isPrivateKey = function (param) {\n  var PrivateKey = require('./privatekey');\n\n  return param instanceof PrivateKey;\n};\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformDER = function (buf, strict) {\n  /* jshint maxstatements: 30 */\n\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n\n  return info;\n};\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformX = function (odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n\n  var info = PublicKey._transformPrivateKey(privkey);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromDER = PublicKey.fromBuffer = function (buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n\n  var info = PublicKey._transformDER(buf, strict);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPoint = function (point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromString = function (str, encoding) {\n  var buf = new Buffer(str, encoding || 'hex');\n\n  var info = PublicKey._transformDER(buf);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\n\n\nPublicKey.getValidationError = function (data) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\n\n\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n/**\n * @returns {Object} A plain object of the PublicKey\n */\n\n\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\n\n\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n\n  if (!this.compressed) {\n    prefix = new Buffer([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n\n    if (odd) {\n      prefix = new Buffer([0x03]);\n    } else {\n      prefix = new Buffer([0x02]);\n    }\n\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\n\n\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\n\n\nPublicKey.prototype.toAddress = function (network) {\n  var Address = require('./address');\n\n  return Address.fromPublicKey(this, network || this.network);\n};\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\n\n\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\n\n\nPublicKey.prototype.inspect = function () {\n  return '<PublicKey: ' + this.toString() + (this.compressed ? '' : ', uncompressed') + '>';\n};\n\nmodule.exports = PublicKey;","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/lib/publickey.js"],"names":["BN","require","Point","Hash","JSUtil","Network","_","$","PublicKey","data","extra","checkArgument","info","_classifyArgs","point","validate","defineImmutable","compressed","network","defaultNetwork","prototype","isUndefined","x","y","_transformObject","_transformDER","Buffer","_isBuffer","_isPrivateKey","_transformPrivateKey","TypeError","undefined","get","param","PrivateKey","Uint8Array","privkey","getG","mul","bn","buf","strict","xbuf","ybuf","slice","length","_transformX","odd","fromX","json","fromPrivateKey","fromDER","fromBuffer","fromPoint","fromString","str","encoding","getValidationError","error","e","isValid","toObject","toJSON","getX","toString","getY","toBuffer","toDER","size","prefix","concat","_getID","sha256ripemd160","toAddress","Address","fromPublicKey","inspect","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(new Buffer(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = new Buffer(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = new Buffer([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = new Buffer([0x03]);\n    } else {\n      prefix = new Buffer([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;\n"]},"metadata":{},"sourceType":"script"}