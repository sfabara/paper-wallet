{"ast":null,"code":"'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar $ = require('../util/preconditions');\n\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n\n  var Input = require('./input');\n\n  var i; // Copy transaction\n\n  var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, subscript) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/lib/transaction/sighash.js"],"names":["buffer","require","Signature","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","_","SIGHASH_SINGLE_BUG","BITS_64_ON","sighash","transaction","sighashType","inputNumber","subscript","Transaction","Input","i","txcopy","shallowCopy","removeCodeseparators","inputs","length","setScript","empty","SIGHASH_NONE","SIGHASH_SINGLE","sequenceNumber","outputs","Buffer","satoshis","fromBuffer","script","SIGHASH_ANYONECANPAY","buf","write","toBuffer","writeInt32LE","ret","sha256sha256","readReverse","sign","privateKey","inputIndex","hashbuf","sig","set","nhashtype","verify","signature","publicKey","checkArgument","isUndefined","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  var i;\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  subscript.removeCodeseparators();\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript);\n  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"]},"metadata":{},"sourceType":"script"}