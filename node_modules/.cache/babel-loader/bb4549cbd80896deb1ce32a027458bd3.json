{"ast":null,"code":"'use strict';\n\nvar bn = require('bn.js');\n\nvar elliptic = require('../../elliptic');\n\nvar utils = elliptic.utils;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })\n\n  if (options.priv) this._importPrivate(options.priv, options.privEnc);\n  if (options.pub) this._importPublic(options.pub, options.pubEnc);\n}\n\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair) return pub;\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair) return priv;\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n  if (pub.isInfinity()) return {\n    result: false,\n    reason: 'Invalid public key'\n  };\n  if (!pub.validate()) return {\n    result: false,\n    reason: 'Public key is not a point'\n  };\n  if (!pub.mul(this.ec.curve.n).isInfinity()) return {\n    result: false,\n    reason: 'Public key * N != O'\n  };\n  return {\n    result: true,\n    reason: null\n  };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  if (!this.pub) this.pub = this.ec.g.mul(this.priv); // compact is optional argument\n\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!enc) return this.pub;\n  var len = this.ec.curve.p.byteLength();\n  var x = this.pub.getX().toArray();\n\n  for (var i = x.length; i < len; i++) x.unshift(0);\n\n  var res;\n\n  if (this.ec.curve.type !== 'mont') {\n    if (compact) {\n      res = [this.pub.getY().isEven() ? 0x02 : 0x03].concat(x);\n    } else {\n      var y = this.pub.getY().toArray();\n\n      for (var i = y.length; i < len; i++) y.unshift(0);\n\n      var res = [0x04].concat(x, y);\n    }\n  } else {\n    res = x;\n  }\n\n  return utils.encode(res, enc);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new bn(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n\n  this.priv = this.priv.mod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n\n  key = utils.toArray(key, enc);\n  if (this.ec.curve.type !== 'mont') return this._importPublicShort(key);else return this._importPublicMont(key);\n};\n\nKeyPair.prototype._importPublicShort = function _importPublicShort(key) {\n  var len = this.ec.curve.p.byteLength();\n\n  if (key[0] === 0x04 && key.length - 1 === 2 * len) {\n    this.pub = this.ec.curve.point(key.slice(1, 1 + len), key.slice(1 + len, 1 + 2 * len));\n  } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {\n    this.pub = this.ec.curve.pointFromX(key[0] === 0x03, key.slice(1, 1 + len));\n  }\n};\n\nKeyPair.prototype._importPublicMont = function _importPublicMont(key) {\n  this.pub = this.ec.curve.point(key, 1);\n}; // ECDH\n\n\nKeyPair.prototype.derive = function derive(pub) {\n  return pub.mul(this.priv).getX();\n}; // ECDSA\n\n\nKeyPair.prototype.sign = function sign(msg) {\n  return this.ec.sign(msg, this);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};","map":{"version":3,"sources":["/home/user/Desktop/paper/node_modules/bitcore-lib-litecoin/node_modules/elliptic/lib/elliptic/ec/key.js"],"names":["bn","require","elliptic","utils","KeyPair","ec","options","priv","pub","_importPrivate","privEnc","_importPublic","pubEnc","module","exports","fromPublic","enc","fromPrivate","prototype","validate","getPublic","isInfinity","result","reason","mul","curve","n","compact","g","len","p","byteLength","x","getX","toArray","i","length","unshift","res","type","getY","isEven","concat","y","encode","getPrivate","toString","key","mod","point","_importPublicShort","_importPublicMont","slice","pointFromX","derive","sign","msg","verify","signature","inspect"],"mappings":"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","sourcesContent":["'use strict';\n\nvar bn = require('bn.js');\n\nvar elliptic = require('../../elliptic');\nvar utils = elliptic.utils;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nmodule.exports = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!enc)\n    return this.pub;\n\n  var len = this.ec.curve.p.byteLength();\n  var x = this.pub.getX().toArray();\n\n  for (var i = x.length; i < len; i++)\n    x.unshift(0);\n\n  var res;\n  if (this.ec.curve.type !== 'mont') {\n    if (compact) {\n      res = [ this.pub.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n    } else {\n      var y = this.pub.getY().toArray();\n      for (var i = y.length; i < len; i++)\n        y.unshift(0);\n      var res = [ 0x04 ].concat(x, y);\n    }\n  } else {\n    res = x;\n  }\n\n  return utils.encode(res, enc);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new bn(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.mod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n\n  key = utils.toArray(key, enc);\n  if (this.ec.curve.type !== 'mont')\n    return this._importPublicShort(key);\n  else\n    return this._importPublicMont(key);\n};\n\nKeyPair.prototype._importPublicShort = function _importPublicShort(key) {\n  var len = this.ec.curve.p.byteLength();\n  if (key[0] === 0x04 && key.length - 1 === 2 * len) {\n    this.pub = this.ec.curve.point(\n      key.slice(1, 1 + len),\n      key.slice(1 + len, 1 + 2 * len));\n  } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {\n    this.pub = this.ec.curve.pointFromX(key[0] === 0x03, key.slice(1, 1 + len));\n  }\n};\n\nKeyPair.prototype._importPublicMont = function _importPublicMont(key) {\n  this.pub = this.ec.curve.point(key, 1);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg) {\n  return this.ec.sign(msg, this);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n"]},"metadata":{},"sourceType":"script"}