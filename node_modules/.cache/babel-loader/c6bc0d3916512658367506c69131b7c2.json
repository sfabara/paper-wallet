{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar BlockHeader = require('./blockheader');\n\nvar BN = require('../crypto/bn');\n\nvar BufferUtil = require('../util/buffer');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar Hash = require('../crypto/hash');\n\nvar Transaction = require('../transaction');\n\nvar $ = require('../util/preconditions');\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\n\n\nfunction Block(arg) {\n  if (!(this instanceof Block)) {\n    return new Block(arg);\n  }\n\n  _.extend(this, Block._from(arg));\n\n  return this;\n} // https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\n\n\nBlock.MAX_BLOCK_SIZE = 1000000;\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\n\nBlock._from = function _from(arg) {\n  var info = {};\n\n  if (BufferUtil.isBuffer(arg)) {\n    info = Block._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = Block._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for Block');\n  }\n\n  return info;\n};\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Object} - An object representing block data\n * @private\n */\n\n\nBlock._fromObject = function _fromObject(data) {\n  var transactions = [];\n  data.transactions.forEach(function (tx) {\n    if (tx instanceof Transaction) {\n      transactions.push(tx);\n    } else {\n      transactions.push(Transaction().fromObject(tx));\n    }\n  });\n  var info = {\n    header: BlockHeader.fromObject(data.header),\n    transactions: transactions\n  };\n  return info;\n};\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\n\n\nBlock.fromObject = function fromObject(obj) {\n  var info = Block._fromObject(obj);\n\n  return new Block(info);\n};\n/**\n * @param {BufferReader} - Block data\n * @returns {Object} - An object representing the block data\n * @private\n */\n\n\nBlock._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  $.checkState(!br.finished(), 'No block data received');\n  info.header = BlockHeader.fromBufferReader(br);\n  var transactions = br.readVarintNum();\n  info.transactions = [];\n\n  for (var i = 0; i < transactions; i++) {\n    info.transactions.push(Transaction().fromBufferReader(br));\n  }\n\n  return info;\n};\n/**\n * @param {BufferReader} - A buffer reader of the block\n * @returns {Block} - An instance of block\n */\n\n\nBlock.fromBufferReader = function fromBufferReader(br) {\n  $.checkArgument(br, 'br is required');\n\n  var info = Block._fromBufferReader(br);\n\n  return new Block(info);\n};\n/**\n * @param {Buffer} - A buffer of the block\n * @returns {Block} - An instance of block\n */\n\n\nBlock.fromBuffer = function fromBuffer(buf) {\n  return Block.fromBufferReader(new BufferReader(buf));\n};\n/**\n * @param {string} - str - A hex encoded string of the block\n * @returns {Block} - A hex encoded string of the block\n */\n\n\nBlock.fromString = function fromString(str) {\n  var buf = new Buffer(str, 'hex');\n  return Block.fromBuffer(buf);\n};\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {Block} - An instance of block\n */\n\n\nBlock.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = new Buffer(data, 'binary');\n  }\n\n  var br = BufferReader(data);\n  br.pos = Block.Values.START_OF_BLOCK;\n\n  var info = Block._fromBufferReader(br);\n\n  return new Block(info);\n};\n/**\n * @returns {Object} - A plain object with the block properties\n */\n\n\nBlock.prototype.toObject = Block.prototype.toJSON = function toObject() {\n  var transactions = [];\n  this.transactions.forEach(function (tx) {\n    transactions.push(tx.toObject());\n  });\n  return {\n    header: this.header.toObject(),\n    transactions: transactions\n  };\n};\n/**\n * @returns {Buffer} - A buffer of the block\n */\n\n\nBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n/**\n * @returns {string} - A hex encoded string of the block\n */\n\n\nBlock.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n */\n\n\nBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n\n  bw.write(this.header.toBuffer());\n  bw.writeVarintNum(this.transactions.length);\n\n  for (var i = 0; i < this.transactions.length; i++) {\n    this.transactions[i].toBufferWriter(bw);\n  }\n\n  return bw;\n};\n/**\n * Will iterate through each transaction and return an array of hashes\n * @returns {Array} - An array with transaction hashes\n */\n\n\nBlock.prototype.getTransactionHashes = function getTransactionHashes() {\n  var hashes = [];\n\n  if (this.transactions.length === 0) {\n    return [Block.Values.NULL_HASH];\n  }\n\n  for (var t = 0; t < this.transactions.length; t++) {\n    hashes.push(this.transactions[t]._getHash());\n  }\n\n  return hashes;\n};\n/**\n * Will build a merkle tree of all the transactions, ultimately arriving at\n * a single point, the merkle root.\n * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n * @returns {Array} - An array with each level of the tree after the other.\n */\n\n\nBlock.prototype.getMerkleTree = function getMerkleTree() {\n  var tree = this.getTransactionHashes();\n  var j = 0;\n\n  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n    for (var i = 0; i < size; i += 2) {\n      var i2 = Math.min(i + 1, size - 1);\n      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n      tree.push(Hash.sha256sha256(buf));\n    }\n\n    j += size;\n  }\n\n  return tree;\n};\n/**\n * Calculates the merkleRoot from the transactions.\n * @returns {Buffer} - A buffer of the merkle root hash\n */\n\n\nBlock.prototype.getMerkleRoot = function getMerkleRoot() {\n  var tree = this.getMerkleTree();\n  return tree[tree.length - 1];\n};\n/**\n * Verifies that the transactions in the block match the header merkle root\n * @returns {Boolean} - If the merkle roots match\n */\n\n\nBlock.prototype.validMerkleRoot = function validMerkleRoot() {\n  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n  if (h.cmp(c) !== 0) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\n\n\nBlock.prototype._getHash = function () {\n  return this.header._getHash();\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function () {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty);\nObject.defineProperty(Block.prototype, 'hash', idProperty);\n/**\n * @returns {string} - A string formatted for the console\n */\n\nBlock.prototype.inspect = function inspect() {\n  return '<Block ' + this.id + '>';\n};\n\nBlock.Values = {\n  START_OF_BLOCK: 8,\n  // Start of block in raw block data\n  NULL_HASH: new Buffer('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\nmodule.exports = Block;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/block/block.js"],"names":["_","require","BlockHeader","BN","BufferUtil","BufferReader","BufferWriter","Hash","Transaction","$","Block","arg","extend","_from","MAX_BLOCK_SIZE","info","isBuffer","_fromBufferReader","isObject","_fromObject","TypeError","data","transactions","forEach","tx","push","fromObject","header","obj","br","checkState","finished","fromBufferReader","readVarintNum","i","checkArgument","fromBuffer","buf","fromString","str","Buffer","fromRawBlock","pos","Values","START_OF_BLOCK","prototype","toObject","toJSON","toBuffer","toBufferWriter","concat","toString","bw","write","writeVarintNum","length","getTransactionHashes","hashes","NULL_HASH","t","_getHash","getMerkleTree","tree","j","size","Math","floor","i2","min","sha256sha256","getMerkleRoot","validMerkleRoot","h","merkleRoot","c","cmp","idProperty","configurable","enumerable","get","_id","id","set","noop","Object","defineProperty","inspect","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar BlockHeader = require('./blockheader');\nvar BN = require('../crypto/bn');\nvar BufferUtil = require('../util/buffer');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar Hash = require('../crypto/hash');\nvar Transaction = require('../transaction');\nvar $ = require('../util/preconditions');\n\n/**\n * Instantiate a Block from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object\n * @returns {Block}\n * @constructor\n */\nfunction Block(arg) {\n  if (!(this instanceof Block)) {\n    return new Block(arg);\n  }\n  _.extend(this, Block._from(arg));\n  return this;\n}\n\n// https://github.com/bitcoin/bitcoin/blob/b5fa132329f0377d787a4a21c1686609c2bfaece/src/primitives/block.h#L14\nBlock.MAX_BLOCK_SIZE = 1000000;\n\n/**\n * @param {*} - A Buffer, JSON string or Object\n * @returns {Object} - An object representing block data\n * @throws {TypeError} - If the argument was not recognized\n * @private\n */\nBlock._from = function _from(arg) {\n  var info = {};\n  if (BufferUtil.isBuffer(arg)) {\n    info = Block._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    info = Block._fromObject(arg);\n  } else {\n    throw new TypeError('Unrecognized argument for Block');\n  }\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Object} - An object representing block data\n * @private\n */\nBlock._fromObject = function _fromObject(data) {\n  var transactions = [];\n  data.transactions.forEach(function(tx) {\n    if (tx instanceof Transaction) {\n      transactions.push(tx);\n    } else {\n      transactions.push(Transaction().fromObject(tx));\n    }\n  });\n  var info = {\n    header: BlockHeader.fromObject(data.header),\n    transactions: transactions\n  };\n  return info;\n};\n\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\nBlock.fromObject = function fromObject(obj) {\n  var info = Block._fromObject(obj);\n  return new Block(info);\n};\n\n/**\n * @param {BufferReader} - Block data\n * @returns {Object} - An object representing the block data\n * @private\n */\nBlock._fromBufferReader = function _fromBufferReader(br) {\n  var info = {};\n  $.checkState(!br.finished(), 'No block data received');\n  info.header = BlockHeader.fromBufferReader(br);\n  var transactions = br.readVarintNum();\n  info.transactions = [];\n  for (var i = 0; i < transactions; i++) {\n    info.transactions.push(Transaction().fromBufferReader(br));\n  }\n  return info;\n};\n\n/**\n * @param {BufferReader} - A buffer reader of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBufferReader = function fromBufferReader(br) {\n  $.checkArgument(br, 'br is required');\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @param {Buffer} - A buffer of the block\n * @returns {Block} - An instance of block\n */\nBlock.fromBuffer = function fromBuffer(buf) {\n  return Block.fromBufferReader(new BufferReader(buf));\n};\n\n/**\n * @param {string} - str - A hex encoded string of the block\n * @returns {Block} - A hex encoded string of the block\n */\nBlock.fromString = function fromString(str) {\n  var buf = new Buffer(str, 'hex');\n  return Block.fromBuffer(buf);\n};\n\n/**\n * @param {Binary} - Raw block binary data or buffer\n * @returns {Block} - An instance of block\n */\nBlock.fromRawBlock = function fromRawBlock(data) {\n  if (!BufferUtil.isBuffer(data)) {\n    data = new Buffer(data, 'binary');\n  }\n  var br = BufferReader(data);\n  br.pos = Block.Values.START_OF_BLOCK;\n  var info = Block._fromBufferReader(br);\n  return new Block(info);\n};\n\n/**\n * @returns {Object} - A plain object with the block properties\n */\nBlock.prototype.toObject = Block.prototype.toJSON = function toObject() {\n  var transactions = [];\n  this.transactions.forEach(function(tx) {\n    transactions.push(tx.toObject());\n  });\n  return {\n    header: this.header.toObject(),\n    transactions: transactions\n  };\n};\n\n/**\n * @returns {Buffer} - A buffer of the block\n */\nBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n\n/**\n * @returns {string} - A hex encoded string of the block\n */\nBlock.prototype.toString = function toString() {\n  return this.toBuffer().toString('hex');\n};\n\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the Block\n */\nBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n  bw.write(this.header.toBuffer());\n  bw.writeVarintNum(this.transactions.length);\n  for (var i = 0; i < this.transactions.length; i++) {\n    this.transactions[i].toBufferWriter(bw);\n  }\n  return bw;\n};\n\n/**\n * Will iterate through each transaction and return an array of hashes\n * @returns {Array} - An array with transaction hashes\n */\nBlock.prototype.getTransactionHashes = function getTransactionHashes() {\n  var hashes = [];\n  if (this.transactions.length === 0) {\n    return [Block.Values.NULL_HASH];\n  }\n  for (var t = 0; t < this.transactions.length; t++) {\n    hashes.push(this.transactions[t]._getHash());\n  }\n  return hashes;\n};\n\n/**\n * Will build a merkle tree of all the transactions, ultimately arriving at\n * a single point, the merkle root.\n * @link https://en.bitcoin.it/wiki/Protocol_specification#Merkle_Trees\n * @returns {Array} - An array with each level of the tree after the other.\n */\nBlock.prototype.getMerkleTree = function getMerkleTree() {\n\n  var tree = this.getTransactionHashes();\n\n  var j = 0;\n  for (var size = this.transactions.length; size > 1; size = Math.floor((size + 1) / 2)) {\n    for (var i = 0; i < size; i += 2) {\n      var i2 = Math.min(i + 1, size - 1);\n      var buf = Buffer.concat([tree[j + i], tree[j + i2]]);\n      tree.push(Hash.sha256sha256(buf));\n    }\n    j += size;\n  }\n\n  return tree;\n};\n\n/**\n * Calculates the merkleRoot from the transactions.\n * @returns {Buffer} - A buffer of the merkle root hash\n */\nBlock.prototype.getMerkleRoot = function getMerkleRoot() {\n  var tree = this.getMerkleTree();\n  return tree[tree.length - 1];\n};\n\n/**\n * Verifies that the transactions in the block match the header merkle root\n * @returns {Boolean} - If the merkle roots match\n */\nBlock.prototype.validMerkleRoot = function validMerkleRoot() {\n\n  var h = new BN(this.header.merkleRoot.toString('hex'), 'hex');\n  var c = new BN(this.getMerkleRoot().toString('hex'), 'hex');\n\n  if (h.cmp(c) !== 0) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * @returns {Buffer} - The little endian hash buffer of the header\n */\nBlock.prototype._getHash = function() {\n  return this.header._getHash();\n};\n\nvar idProperty = {\n  configurable: false,\n  enumerable: true,\n  /**\n   * @returns {string} - The big endian hash buffer of the header\n   */\n  get: function() {\n    if (!this._id) {\n      this._id = this.header.id;\n    }\n    return this._id;\n  },\n  set: _.noop\n};\nObject.defineProperty(Block.prototype, 'id', idProperty);\nObject.defineProperty(Block.prototype, 'hash', idProperty);\n\n/**\n * @returns {string} - A string formatted for the console\n */\nBlock.prototype.inspect = function inspect() {\n  return '<Block ' + this.id + '>';\n};\n\nBlock.Values = {\n  START_OF_BLOCK: 8, // Start of block in raw block data\n  NULL_HASH: new Buffer('0000000000000000000000000000000000000000000000000000000000000000', 'hex')\n};\n\nmodule.exports = Block;\n"]},"metadata":{},"sourceType":"script"}