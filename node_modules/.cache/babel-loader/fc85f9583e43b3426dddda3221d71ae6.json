{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar Point = require('./point');\n\nvar Signature = require('./signature');\n\nvar PublicKey = require('../publickey');\n\nvar Random = require('./random');\n\nvar Hash = require('./hash');\n\nvar BufferUtil = require('../util/buffer');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n\n  if (obj) {\n    this.set(obj);\n  }\n};\n/* jshint maxcomplexity: 9 */\n\n\nECDSA.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\n\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nECDSA.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nECDSA.prototype.calci = function () {\n  for (var i = 0; i < 4; i++) {\n    this.sig.i = i;\n    var Qprime;\n\n    try {\n      Qprime = this.toPublicKey();\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n\n    if (Qprime.point.eq(this.pubkey.point)) {\n      this.sig.compressed = this.pubkey.compressed;\n      return this;\n    }\n  }\n\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\n\nECDSA.fromString = function (str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\n\nECDSA.prototype.randomK = function () {\n  var N = Point.getN();\n  var k;\n\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n\n  this.k = k;\n  return this;\n}; // https://tools.ietf.org/html/rfc6979#section-3.2\n\n\nECDSA.prototype.deterministicK = function (badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n\n  var v = new Buffer(32);\n  v.fill(0x01);\n  var k = new Buffer(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN(); // also explained in 3.2, we must ensure T is in the proper range (0, N)\n\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  this.k = T;\n  return this;\n}; // Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\n\n\nECDSA.prototype.toPublicKey = function () {\n  /* jshint maxstatements: 25 */\n  var i = this.sig.i;\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s; // A set LSB signifies that the y-coordinate is odd\n\n  var isYOdd = i & 1; // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n\n  var isSecondKey = i >> 1;\n  var n = Point.getN();\n  var G = Point.getG(); // 1.1 Let x = r + jn\n\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x); // 1.4 Check that nR is at infinity\n\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  } // Compute -e from e\n\n\n  var eNeg = e.neg().mod(n); // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n\n  var rInv = r.invm(n); //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n  return pubkey;\n};\n\nECDSA.prototype.sigError = function () {\n  /* jshint maxstatements: 25 */\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).mod(n);\n  var u2 = sinv.mul(r).mod(n);\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().mod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  } else {\n    return false;\n  }\n};\n\nECDSA.toLowS = function (s) {\n  //enforce low s\n  //see BIP 62, \"low S values in signatures\"\n  if (s.gt(BN.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n\n  return s;\n};\n\nECDSA.prototype._findSignature = function (d, e) {\n  var N = Point.getN();\n  var G = Point.getG(); // try different values of k until r, s are valid\n\n  var badrs = 0;\n  var k, Q, r, s;\n\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n\n    badrs++;\n    k = this.k;\n    Q = G.mul(k);\n    r = Q.x.mod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).mod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = ECDSA.toLowS(s);\n  return {\n    s: s,\n    r: r\n  };\n};\n\nECDSA.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n\n  obj.compressed = this.pubkey.compressed;\n  this.sig = new Signature(obj);\n  return this;\n};\n\nECDSA.prototype.signRandomK = function () {\n  this.randomK();\n  return this.sign();\n};\n\nECDSA.prototype.toString = function () {\n  var obj = {};\n\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n\n  return JSON.stringify(obj);\n};\n\nECDSA.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n\n  return this;\n};\n\nECDSA.sign = function (hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\n\nECDSA.verify = function (hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\n\nmodule.exports = ECDSA;","map":{"version":3,"sources":["/home/user/Desktop/react-wallet/node_modules/bitcore-lib-litecoin/lib/crypto/ecdsa.js"],"names":["BN","require","Point","Signature","PublicKey","Random","Hash","BufferUtil","_","$","ECDSA","obj","set","prototype","hashbuf","endian","privkey","pubkey","publicKey","sig","k","verified","privkey2pubkey","toPublicKey","calci","i","Qprime","e","console","error","point","eq","compressed","undefined","Error","fromString","str","JSON","parse","randomK","N","getN","fromBuffer","getRandomBuffer","lt","gt","Zero","deterministicK","badrs","isUndefined","v","Buffer","fill","x","bn","toBuffer","size","reverse","sha256hmac","concat","T","checkArgument","r","s","isYOdd","isSecondKey","n","G","getG","add","R","fromX","nR","mul","isInfinity","eNeg","neg","mod","rInv","invm","Q","fromPoint","sigError","isBuffer","length","sinv","u1","u2","p","mulAdd","getX","cmp","toLowS","sub","_findSignature","d","sign","checkState","signRandomK","toString","stringify","verify","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar Point = require('./point');\nvar Signature = require('./signature');\nvar PublicKey = require('../publickey');\nvar Random = require('./random');\nvar Hash = require('./hash');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\n\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n  if (obj) {\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 9 */\nECDSA.prototype.set = function(obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nECDSA.prototype.privkey2pubkey = function() {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nECDSA.prototype.calci = function() {\n  for (var i = 0; i < 4; i++) {\n    this.sig.i = i;\n    var Qprime;\n    try {\n      Qprime = this.toPublicKey();\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n\n    if (Qprime.point.eq(this.pubkey.point)) {\n      this.sig.compressed = this.pubkey.compressed;\n      return this;\n    }\n  }\n\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\n\nECDSA.fromString = function(str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\n\nECDSA.prototype.randomK = function() {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  this.k = k;\n  return this;\n};\n\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nECDSA.prototype.deterministicK = function(badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n  var v = new Buffer(32);\n  v.fill(0x01);\n  var k = new Buffer(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  this.k = T;\n  return this;\n};\n\n// Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\nECDSA.prototype.toPublicKey = function() {\n  /* jshint maxstatements: 25 */\n  var i = this.sig.i;\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().mod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n\n  return pubkey;\n};\n\nECDSA.prototype.sigError = function() {\n  /* jshint maxstatements: 25 */\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = this.sig.r;\n  var s = this.sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).mod(n);\n  var u2 = sinv.mul(r).mod(n);\n\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().mod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  } else {\n    return false;\n  }\n};\n\nECDSA.toLowS = function(s) {\n  //enforce low s\n  //see BIP 62, \"low S values in signatures\"\n  if (s.gt(BN.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\n\nECDSA.prototype._findSignature = function(d, e) {\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n    badrs++;\n    k = this.k;\n    Q = G.mul(k);\n    r = Q.x.mod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).mod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = ECDSA.toLowS(s);\n  return {\n    s: s,\n    r: r\n  };\n\n};\n\nECDSA.prototype.sign = function() {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n  obj.compressed = this.pubkey.compressed;\n\n  this.sig = new Signature(obj);\n  return this;\n};\n\nECDSA.prototype.signRandomK = function() {\n  this.randomK();\n  return this.sign();\n};\n\nECDSA.prototype.toString = function() {\n  var obj = {};\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n  return JSON.stringify(obj);\n};\n\nECDSA.prototype.verify = function() {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n  return this;\n};\n\nECDSA.sign = function(hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\n\nECDSA.verify = function(hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\n\nmodule.exports = ECDSA;\n"]},"metadata":{},"sourceType":"script"}